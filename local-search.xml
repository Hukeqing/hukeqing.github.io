<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CodeforcesRound#697(Div. 3)</title>
    <link href="/2021/01/26/acm/CodeforcesRound697(Div.%203)/"/>
    <url>/2021/01/26/acm/CodeforcesRound697(Div.%203)/</url>
    
    <content type="html"><![CDATA[<p><em>自南京区域赛结束之后就一直在准备期末考试，直到最近结束考试之后开始了复建的生活，这场 Div3 除了 D 题因为爆了 int 然后卡了，G题真的没在比赛期间想出来，其他题目都是非常顺利的解决掉了，且只用了一个小时</em></p><h1 id="A-Odd-Divisor"><a href="#A-Odd-Divisor" class="headerlink" title="A. Odd Divisor"></a>A. Odd Divisor</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数，请问它是否存在一个不为 1 的奇因子</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为除 1 以外的所有奇因子都可以分解出至少一个奇质因子，那么只需要找到那些不包含奇质因子的数进行排查就行。而不包含奇质因子的数字很明显就是所有的 2 的幂次，所以打表就可以了。注意别忘记范围超过了 int</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; err;<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">62</span>; ++i) &#123;<br>        err.insert(cur);<br>        cur &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> _;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">int</span> tmp;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; tmp;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; (err.count(tmp) ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-New-Year’s-Number"><a href="#B-New-Year’s-Number" class="headerlink" title="B. New Year’s Number"></a>B. New Year’s Number</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个数，请问它是不是 n 个 2020 和 m 个 2021 相加得到的</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>把 2021 看成 2020 + 1，那么就变成了 (n + m) 个 2020 和 m 个 1 相加得到，由于 n 肯定是自然数，则只要满足这个数除以 2020 的商(也就是 n + m 部分)大于等于余数(也就是 m)即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> _;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">int</span> tmp;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; tmp;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; (tmp / <span class="hljs-number">2020</span> &gt;= tmp % <span class="hljs-number">2020</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Ball-in-Berland"><a href="#C-Ball-in-Berland" class="headerlink" title="C. Ball in Berland"></a>C. Ball in Berland</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>有两组人，分别为 a 和 b ，有 k 对组合，每对组合都是从 a 中选出一个，从 b 中选出一个。你现在需要选出两对组合，使得这两对组合不会发生冲突，即不会出现 a 中的人同时参与了这两个组合或者 b 中的人同时参与了这两个组合或者两者都同时参与</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>可以用类似容斥的办法解决。因为保证了每一对组合都不同，所以当我选出一对的时候，那么还有 <code>k - cnt[a] - cnt[b] + 1</code> 对我可以选，其中的 <code>cnt</code> 为这个人参与的组合数量。只需要遍历所有的组合，然后对于每对组合进行求解即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> _;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">int</span> a, b, k;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;<br>        vector&lt;int&gt; ca(a + 1), cb(b + 1);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; p(k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">int</span> u;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; u;<br>            p[i].first = u;<br>            ca[u]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">int</span> u;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; u;<br>            p[i].second = u;<br>            cb[u]++;<br>        &#125;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) ans += k - ca[p[i].first] - cb[p[i].second] + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; ans / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Cleaning-the-Phone"><a href="#D-Cleaning-the-Phone" class="headerlink" title="D. Cleaning the Phone"></a>D. Cleaning the Phone</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一组物品，他们有各自的代价和价值，其中代价只有 1 或者 2 两种，请问如何选择物品，使得代价尽可能小的情况下满足所需要的价值</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>直接考虑枚举，比如枚举选择了 x 件代价为 1 的物品，求出这时候至少需要多少件代价为 2 的物品，然后枚举所有情况，输出最小的情况即可。</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> _;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">int</span> n, m;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mem</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; data[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-built_in">cin</span> &gt;&gt; mem[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> op;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>            data[op - <span class="hljs-number">1</span>].push_back(mem[i]);<br>        &#125;<br>        sort(data[<span class="hljs-number">0</span>].begin(), data[<span class="hljs-number">0</span>].end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>        sort(data[<span class="hljs-number">1</span>].begin(), data[<span class="hljs-number">1</span>].end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>        <span class="hljs-keyword">int</span> ans = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; data[<span class="hljs-number">0</span>].size(); ++i) data[<span class="hljs-number">0</span>][i] += data[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; data[<span class="hljs-number">1</span>].size(); ++i) data[<span class="hljs-number">1</span>][i] += data[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">auto</span> iter = lower_bound(data[<span class="hljs-number">1</span>].begin(), data[<span class="hljs-number">1</span>].end(), m);<br>        <span class="hljs-keyword">if</span> (iter != data[<span class="hljs-number">1</span>].end()) ans = min(ans, (<span class="hljs-keyword">int</span>) (iter - data[<span class="hljs-number">1</span>].begin() + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>);<br><br>        iter = lower_bound(data[<span class="hljs-number">0</span>].begin(), data[<span class="hljs-number">0</span>].end(), m);<br>        <span class="hljs-keyword">if</span> (iter != data[<span class="hljs-number">0</span>].end()) ans = min(ans, (<span class="hljs-keyword">int</span>) ((iter - data[<span class="hljs-number">0</span>].begin() + <span class="hljs-number">1</span>)));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data[<span class="hljs-number">0</span>].size(); ++i) &#123;<br>            iter = lower_bound(data[<span class="hljs-number">1</span>].begin(), data[<span class="hljs-number">1</span>].end(), m - data[<span class="hljs-number">0</span>][i]);<br>            <span class="hljs-keyword">if</span> (iter != data[<span class="hljs-number">1</span>].end()) ans = min(ans, (<span class="hljs-keyword">int</span>) ((iter - data[<span class="hljs-number">1</span>].begin() + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> + i + <span class="hljs-number">1</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data[<span class="hljs-number">1</span>].size(); ++i) &#123;<br>            iter = lower_bound(data[<span class="hljs-number">0</span>].begin(), data[<span class="hljs-number">0</span>].end(), m - data[<span class="hljs-number">1</span>][i]);<br>            <span class="hljs-keyword">if</span> (iter != data[<span class="hljs-number">0</span>].end()) ans = min(ans, (<span class="hljs-keyword">int</span>) ((iter - data[<span class="hljs-number">0</span>].begin() + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span> * (i + <span class="hljs-number">1</span>)));<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; (ans == INT_MAX ? <span class="hljs-number">-1</span> : ans) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Advertising-Agency"><a href="#E-Advertising-Agency" class="headerlink" title="E. Advertising Agency"></a>E. Advertising Agency</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一组数据，要求你从中取出 k 个数据，使得这 k 个数据的之和最大，问有几种取法</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>首先取最大必然只能从大到小取，直到取满 k 个。但是在取最后几个相同的值的时候，由于有多个选择，则可以产生多个方案。而这个方案数量很明显即为组合数。</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1100</span>;<br><br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % mod;<br>        a = a * a % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>ll fac[N], ifac[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> siz)</span> </span>&#123;<br>    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= siz; i++)<br>        fac[i] = i * fac[i - <span class="hljs-number">1</span>] % mod;<br>    ifac[siz] = qpow(fac[siz], mod - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = siz; i &gt;= <span class="hljs-number">1</span>; i--) ifac[i - <span class="hljs-number">1</span>] = ifac[i] * i % mod;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n, ll m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    init(<span class="hljs-number">1050</span>);<br>    <span class="hljs-keyword">int</span> _;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">int</span> n, k;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> tmp;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; tmp;<br>            mp[tmp]++;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> iter = mp.rbegin();<br>        <span class="hljs-keyword">while</span> (iter != mp.rend()) &#123;<br>            <span class="hljs-keyword">if</span> (k &gt; iter-&gt;second) &#123;<br>                k -= iter-&gt;second;<br>                iter++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; C(iter-&gt;second, k) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Unusual-Matrix"><a href="#F-Unusual-Matrix" class="headerlink" title="F. Unusual Matrix"></a>F. Unusual Matrix</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你两个 01 矩阵，问能否通过下面两个方式将第一个矩阵转为和第二个矩阵一样</p><ul><li>将一行的值翻转</li><li>将一列的值翻转</li></ul><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>由于是翻转相同，那么首先直接对这两个矩阵做异或，可以得到一个矩阵，接下来只需要把这个矩阵给转为只有 0 或者只有 1 的矩阵即可</p><p>这时候其实可以模拟，假定这行第一个值为 1 则翻转，否者不翻转，然后最后判定是否为纯 0 矩阵</p><p>但是这样太麻烦了，其实可以直接判断相邻两行之间是否相同或者相异，即任意两行或者两列的异或结果全为 0 或者 全为 1 则可以，否则不可以</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> _;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>        vector&lt;string&gt; data1(n), data2(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-built_in">cin</span> &gt;&gt; data1[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-built_in">cin</span> &gt;&gt; data2[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) data1[i][j] = (data1[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ (data2[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">char</span> tmp = data1[i][<span class="hljs-number">0</span>] ^ data1[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> ((data1[i][j] ^ data1[i - <span class="hljs-number">1</span>][j]) != tmp) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Strange-Beauty"><a href="#G-Strange-Beauty" class="headerlink" title="G. Strange Beauty"></a>G. Strange Beauty</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一组数列，请问至少需要删除几个数字，使得整个数列的任意两个值满足大数取模小数为 0</p><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>利用素数筛的方式来 dp 求算最多能有多少个值能满足此条件，相减就能得到答案</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> _;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>        vector&lt;int&gt; cnt(2e5 + 1), dp(2e5 + 1);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> tmp;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; tmp;<br>            cnt[tmp]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2e5</span>; ++i) &#123;<br>            dp[i] += cnt[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + i; j &lt;= <span class="hljs-number">2e5</span>; j += i) dp[j] = max(dp[j], dp[i]);<br>            ans = max(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下的 NTFS 驱动器索引 BUG</title>
    <link href="/2021/01/18/develop-note/windows-ntfs/"/>
    <url>/2021/01/18/develop-note/windows-ntfs/</url>
    
    <content type="html"><![CDATA[<h1 id="NTFS-BUG"><a href="#NTFS-BUG" class="headerlink" title="NTFS BUG"></a>NTFS BUG</h1><div class="note note-danger">            <font color=red size=5>警告，请千万不要在 Windows 下的命令行中运行此命令，或者以其他等价的方式访问</font>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> c:\:<span class="hljs-variable">$i30</span>:<span class="hljs-variable">$bitmap</span><br></code></pre></td></tr></table></figure><div class="note note-danger">            <font color=red size=5>警告，请千万不要在 Windows 下的命令行中运行此命令，或者以其他等价的方式访问</font>          </div><p>当你试图进入、访问此目录时，就有机会导致 NTFS 驱动器索引损坏，此问题的触发方式包括但不限于</p><ul><li>在极低权限的命令行中执行此命令</li><li>在 powershell 中执行此命令</li><li>在浏览器中试图访问此 <code>c:\:$i30:$bitmap</code> 地址</li><li>其他试图访问此地址的程序</li></ul><p>触发后，系统将会提示磁盘错误，需要修复，并提示重启电脑。重启后，电脑将会进入磁盘修复，Windows 将会试图修复此问题</p><p>部分电脑可以修复此问题，并且正常进入系统，而部分电脑将会无法修复此 BUG，且无法进入系统。</p><h1 id="我的经历"><a href="#我的经历" class="headerlink" title="我的经历"></a>我的经历</h1><p>当我第一次得到此命令的时候，我尝试在 Google 中搜索此地址含义，我直接将其输入到 chrome 的地址栏里，然后我直接按下了回车键！！！</p><p>然后悲剧诞生了，我的电脑提示我，磁盘出错需要修复</p><h2 id="尝试修复-1"><a href="#尝试修复-1" class="headerlink" title="尝试修复-1"></a>尝试修复-1</h2><p>使用 Windows 的磁盘修复工具。</p><ul><li>驱动卷-属性-工具-检查驱动器中的文件系统错误</li><li>提示我需要重启电脑，重启</li><li>进入系统前尝试修复错误</li><li>没有找到错误，但是无法进入系统</li></ul><h2 id="尝试修复-2"><a href="#尝试修复-2" class="headerlink" title="尝试修复-2"></a>尝试修复-2</h2><p>直接删除 C 盘，然后通过 DG 等软件重建分区表</p><ul><li>进入 DG，备份分区表</li><li>直接删除 C 盘</li><li>使用 DG 直接找回分区表</li><li>找回了分区表，但是重启之后仍然无法进入系统</li></ul><h2 id="尝试修复-3"><a href="#尝试修复-3" class="headerlink" title="尝试修复-3"></a>尝试修复-3</h2><p>仔细想想，为什么我不能进入 Windows，但是 PE 可以进入 C 盘呢？同样是同一块硬盘，如果真的是 NTFS 的问题，那为什么我的 PE 仍然能够正确的读取出我的硬盘内的文件内容？使用了好几个不同的软件试图扫描 NTFS 的结果均为正常、无错误</p><p>开始怀疑这是不是 Windows 因为遇到了这个问题而产生的 BUG 而并非 NTFS 的问题</p><ul><li>使用 Dism++，进行恢复系统受损</li><li>修复完成重启系统</li><li>手动跳过磁盘检查</li><li><font color=red>成功</font>进入系统</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>NTFS</tag>
      
      <tag>BUG</tag>
      
      <tag>短笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2021/01/07/notebook/Compilation-principle/"/>
    <url>/2021/01/07/notebook/Compilation-principle/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>编译：将高级语言翻译成汇编语言或机器语言的过程</li></ul><h2 id="编译过程的五个阶段"><a href="#编译过程的五个阶段" class="headerlink" title="编译过程的五个阶段"></a>编译过程的五个阶段</h2><ol><li>词法分析</li><li>语法分析</li><li>词义分析与中间代码生成</li><li>优化</li><li>目标代码生成</li></ol><h2 id="编译过程的八个部分"><a href="#编译过程的八个部分" class="headerlink" title="编译过程的八个部分"></a>编译过程的八个部分</h2><ol><li>词法分析程序</li><li>语法分析程序</li><li>语义分析程序</li><li>中间代码生成</li><li>代码优化程序</li><li>目标代码生成程序</li><li>错误检查和处理程序</li><li>信息表管理程序</li></ol><h1 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表 $\sum$ 是一个<font color=red>有穷的符号集合</font>，符号包括了字母、数字、标点符号……</p><h3 id="字母表上的运算"><a href="#字母表上的运算" class="headerlink" title="字母表上的运算"></a>字母表上的运算</h3><ul><li>乘积：<script type="math/tex">\sum_1 \sum_2 = \{ab | a \in \sum_1 , b \in \sum_2 \}</script>。即从 $\sum_1$ 中选择一个字符串，和 $\sum_2$ 中的一个字符串连接</li><li>幂：即多次进行自我乘积的过程。字母表的 $n$ 次幂指长度为 $n$ 的符号串构成的集合</li><li>正闭包：长度正数的符号串构成的集合（任意一个合理的符号串均属于字母表的正闭包）记作：$\sum^+$</li><li>克林闭包：允许长度为 $0$ 的正闭包，记作：$\sum^*$</li></ul><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><ul><li>串是字母表的克林闭包的一个元素，是字母表中符号的一个有穷序列</li><li>串的长度通常记作 $|s|$，指的是串 $s$ 中的符号个数</li><li>空串是长度为 $0$ 的串，用 $\varepsilon$ 表示，$|\varepsilon | = 0$</li></ul><h3 id="串上的运算"><a href="#串上的运算" class="headerlink" title="串上的运算"></a>串上的运算</h3><ul><li>连接</li><li>幂</li></ul><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p>对于文法 $G$，可以定义为 $G = (V_T, V_N, P, S)$</p><ul><li>$V_T$：终结符集合，表示的是一系列不可以被符号替换的符号，例如“宾语”不是一个终结符，而“水果”则是一个终结符。非空有穷集</li><li>$V_N$：非终结符集合，表示的是一系列一定可以被符号替换的符号，在等式中至少会出现一次在等号左侧的符号。非空有穷集</li><li>$P$：产生式/规则，表示的是替换过程，可以表示为 $\alpha \rightarrow \beta$，其中 $\alpha \in (V_N \cup V_T)^*$且至少包含一个非终结符。$\beta \in (V_N \cup V_T)^*$。非空有穷集</li><li>$S$：开始符号，表示的是该文法中最大的语法成分，例如 $S = 句子$</li></ul><h3 id="产生式的简写"><a href="#产生式的简写" class="headerlink" title="产生式的简写"></a>产生式的简写</h3><p>对于含有相同左部的产生式，可以通过“或”运算简写<br>例如对于</p><script type="math/tex; mode=display">\alpha \rightarrow \beta_1 , \alpha \rightarrow \beta_2 , \dots , \alpha \rightarrow \beta_n</script><p>可以简写为</p><script type="math/tex; mode=display">\alpha \rightarrow \beta_1 | \beta_2 | \dots | \beta_n</script><h3 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h3><ul><li>下列符号是终结符<ul><li>字母表中排在前面的小写字母，如 a、b、c</li><li>运算符，如+、*等</li><li>标点符号，如括号、逗号</li><li>数字，0、1、……、9</li><li>粗体字符串，如<strong>id</strong>、<strong>if</strong></li></ul></li><li>下列符号是非终结符<ul><li>字母表中排在前面的大写字母，如 A、B、C</li><li>字母 S，通常表示开始符号</li><li>小写、斜体的名字，如<em>expr</em>、<em>stmt</em></li><li>代表程序构造的大写字母，如 $E$(表达式)、$T$(项)、$F$(因子)</li></ul></li><li>字母表中排在后面的大写字母表示文法符号(终结符或非终结符)，如 $X、Y、Z$</li><li>字母表中排在后面的小写字母表示终结符号串，如 $u、v、\dots 、z$</li><li>小写希腊字母表示文法符号串 $\alpha 、\beta 、 \gamma$</li><li>除非特别说明，第一个产生式的左部就是开始符号</li></ul><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>从语言的规则<font color=red>推导</font>生成语言的过程</p><p>根据规则，可以将符号串推成另一个符号串的过程称为推导。用产生式的右部替换产生式的左部</p><p>如果是经过多次推导得到，则记为 $a_0 \Rightarrow^n a_n$</p><p>$a_0 \Rightarrow^+ a_n$ 表示经过至少一步推导得到<br>$a_0 \Rightarrow^* a_n$ 表示经过任意步数推导得到</p><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><p>根据语言的规则<font color=red>识别</font>语言的过程</p><p>根据规则，可以将符号串还原成。将产生式的右部替换为产生式的左部</p><h3 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h3><ul><li>如果 $S \Rightarrow^* \alpha, \alpha \in (V_T \cup V_N)^*$ 则称 $\alpha$ 是语法 $G$ 的一个句型</li><li>一个句型中既可以包含终结符，也可以包含非终结符，也可以是空串</li><li>如果 $S \Rightarrow^* w, w \in V_T^*$ 则称 $w$ 是 $G$ 的一个句子</li><li>句子是不包含任何非终结符的句型</li><li>由文法推导出的所有句子构成的集合称为：文法 $G$ 生成的语言，记为 $L(G)$，即</li></ul><script type="math/tex; mode=display">L(G) = \{w | S \Rightarrow^* w, w \in V_T^* \}</script><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><h3 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h3><p>对于 $\forall \alpha \rightarrow \beta \in P$，满足 $\alpha$ 中至少包含一个非终结符</p><h3 id="1型文法-上下文有关文法"><a href="#1型文法-上下文有关文法" class="headerlink" title="1型文法(上下文有关文法)"></a>1型文法(上下文有关文法)</h3><p>对于 $\forall \alpha \rightarrow \beta \in P$，满足 $|\alpha| \leq |\beta|$</p><p>也可以理解为对于 $\forall \alpha A \beta \rightarrow \alpha \gamma \beta \in P$，其中 $\alpha$、$\beta$ 可以为 $\varepsilon$，满足 $\gamma \neq \varepsilon$(在 $A = S$ 的情况下，此等式可以成立)</p><h3 id="2型文法-上下文无关文法"><a href="#2型文法-上下文无关文法" class="headerlink" title="2型文法(上下文无关文法)"></a>2型文法(上下文无关文法)</h3><p>对于 $\forall \alpha \rightarrow \beta \in P$，满足 $\alpha$ 是一个非终结符</p><h3 id="3型文法-正规文法"><a href="#3型文法-正规文法" class="headerlink" title="3型文法(正规文法)"></a>3型文法(正规文法)</h3><p>对于 $\forall \alpha \rightarrow \beta \in P$，满足 $\alpha$ 是一个非终结符，而 $\beta$ 只能是空串、一个终结符号或者一个终结符号和一个非终结符号</p><h2 id="CFG-分析树"><a href="#CFG-分析树" class="headerlink" title="CFG 分析树"></a>CFG 分析树</h2><p>分析树是推导的图形化表示</p><p><img src="/image/notebook/Compilation-principle/1.png" alt="CFG"></p><h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(简称：RE)是一种描述正则语言的表示方法，正则表达式可以由较小的正则表达式按照特定规则递归地构建。每个正则表达式 $r$ 定义(表示)一个语言，记为 $L(r)$。这个语言也是根据 $r$ 的子表达式所表示的语言递归定义的</p><h3 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h3><ul><li>$\varepsilon$ 是一个 RE，<script type="math/tex">L(\varepsilon) = \{ \varepsilon \}</script></li><li>如果 $a \in \sum(字母表)$，则 $a$ 是一个 RE，<script type="math/tex">L(a) = \{a\}</script></li><li><p>加入 $r$ 和 $s$ 都是 RE，表示的语言分别是 $L(r)$ 和 $L(s)$，则</p><ul><li>$r|s$ 是一个 RE，$L(r|s) = L(r) \cup L(s)$</li><li>$rs$ 是一个 RE，$L(rs) = L(r)L(s)$</li><li>$r^*$ 是一个 RE，$L(r^*) = (L(r))^*$</li><li>$(r)$ 是一个 RE，$L((r)) = L(r)$</li></ul></li><li><p>可以用RE定义的语言叫做正则语言(regular language)或正则集合(regular set)</p></li><li>对任何正则文法 $G$，存在定义同一语言的正则表达式 $r$</li><li>对任何正则表达式 $r$，存在生成同一语言的正则文法 $G$</li></ul><h3 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h3><p>给一些RE命名，并在之后的RE中像使用字母表中的符号一样使用这些名字</p><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><p>具有一系列离散的输入输出信息和有穷数目的内部状态的系统</p><h3 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h3><ul><li>确定的有穷自动机</li><li>不确定的有穷自动机</li></ul><h3 id="确定的有穷自动机-DFA"><a href="#确定的有穷自动机-DFA" class="headerlink" title="确定的有穷自动机(DFA)"></a>确定的有穷自动机(DFA)</h3><p>对于任意的一个输入，自动机都唯一地确定了下一个状态</p><p>定义 $M=(S, \sum, \delta, s_0, F)$ 为一个确定的有穷自动机</p><ul><li>$S$：有穷状态集</li><li>$\sum$：输入的字母表，即输入的符号集合($\varepsilon \notin \sum $)</li><li>$\delta$：$\forall s \in S, a \in \sum, \delta(s, a)$ 表示从状态 $s$ 出发，沿着标记为 $a$ 的边所能到达的状态</li><li>$s_0$：开始状态，$s_0 \in S$</li><li>$F$：接收状态(终止状态)的集合，$F \subseteq S$</li></ul><p>确定的有穷自动机可以通过状态图来表示</p><p><img src="/image/notebook/Compilation-principle/2.png" alt="DFA状态图"></p><p>初始结点通常用 $\Rightarrow$ 表示，终态结点通常为双圈表示</p><p>确定的有穷自动机还可以使用表格来表示其状态，例如上述的状态图可以表示为</p><div class="table-container"><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">$S_0$</td><td style="text-align:center">$S_1$</td><td style="text-align:center">$S_0$</td><td>0</td></tr><tr><td style="text-align:center">$S_1$</td><td style="text-align:center">$S_1$</td><td style="text-align:center">$S_2$</td><td>0</td></tr><tr><td style="text-align:center">$S_2$</td><td style="text-align:center">$S_1$</td><td style="text-align:center">$S_0$</td><td>1</td></tr></tbody></table></div><p>通常，在表格对应行的右端通过01的标注表示这个状态为终态</p><p>对于 $\sum^*$ 中的任意符号串 $t$，如果在状态图中存在一条从初态到某一终态的路径，且这条路径上所有弧的标记符连接起来等于 $t$，则称 $t$ 可以被此 DFA 接受</p><h3 id="不确定的有穷自动机-NFA"><a href="#不确定的有穷自动机-NFA" class="headerlink" title="不确定的有穷自动机(NFA)"></a>不确定的有穷自动机(NFA)</h3><p>收到一个符号，可能进入不同的状态</p><p>定义 $M=(S, \sum, \delta, s_0, F)$ 为一个确定的有穷自动机</p><ul><li>$S$：是一个有穷集，它的每一个元素称为一个状态</li><li>$\sum$：是一个有穷字母表，它的每一个元素称为一个输入符号</li><li>$\delta$：表示一个转移函数，可以描述为<script type="math/tex">S \times (\sum \cup \{\varepsilon \}) \rightarrow P(S)</script>。$P(S)$ 是 $S$ 的一个子集</li><li>$s_0$：$S_0 \in S$，表示自动机的初始态</li><li>$F$：接收状态(终止状态)的集合，$F \subseteq S$</li></ul><p>NFA 也可以通过状态图来表示和表格进行表示，与 DFA 的状态图类似</p><h3 id="DFA-和-NFA-的等价性"><a href="#DFA-和-NFA-的等价性" class="headerlink" title="DFA 和 NFA 的等价性"></a>DFA 和 NFA 的等价性</h3><ul><li>对任何非确定的有穷自动机 N ，存在定义同一语言的确定的有穷自动机 D</li><li>对任何确定的有穷自动机 D ，存在定义同一语言的非确定的有穷自动机 N</li></ul><h3 id="从正则表达式转为-NFA"><a href="#从正则表达式转为-NFA" class="headerlink" title="从正则表达式转为 NFA"></a>从正则表达式转为 NFA</h3><p>参考下面两张图<br><img src="/image/notebook/Compilation-principle/3.png" alt="RE转NFA-1"></p><p><img src="/image/notebook/Compilation-principle/4.png" alt="RE转NFA-2"></p><h3 id="NFA-转-DFA"><a href="#NFA-转-DFA" class="headerlink" title="NFA 转 DFA"></a>NFA 转 DFA</h3><p>步骤：</p><ol><li>从起始状态开始，通过所有的路径，得到新的状态集的组合</li><li>将所有新的状态集组合重新通过路径，重复操作直到没有新的组合</li><li>将状态集作为 DFA 的结点，建成 DFA 状态机</li><li>如果新的状态包含原来的可接受状态(终止状态)，则认为新的状态也是可接受状态</li></ol><blockquote><p>以下图为例<br><img src="/image/notebook/Compilation-principle/NFA-example-1.png" alt="NFA示例"><br>画出如下的表格</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">状态</th><th style="text-align:center">a</th><th style="text-align:center">b</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0,1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0,1</td><td style="text-align:center">0,1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table></div><blockquote><p>将序号代替状态，重新绘图<br><img src="/image/notebook/Compilation-principle/NFA2DFA-2.png" alt="NFA转DFA-1"></p></blockquote><h3 id="DFA-最小化"><a href="#DFA-最小化" class="headerlink" title="DFA 最小化"></a>DFA 最小化</h3><ul><li>删除从起始结点开始的不可到达的状态</li><li>合并所有的等价状态<ul><li>两个状态必须同时是可接受状态或不可接受状态</li><li>对于所有输入的符号，两个状态都必须转换到等价的状态里</li></ul></li></ul><blockquote><p>以上方的图为例，易得状态 1 和状态 2 是等价状态，所以合并得到</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">状态</th><th style="text-align:center">a</th><th style="text-align:center">b</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><blockquote><p>最终得到<br><img src="/image/notebook/Compilation-principle/NFA2DFA-1.png" alt="DFA最小化-2"></p></blockquote><h1 id="自顶向下语法分析方法"><a href="#自顶向下语法分析方法" class="headerlink" title="自顶向下语法分析方法"></a>自顶向下语法分析方法</h1><h2 id="自顶向下的分析思想"><a href="#自顶向下的分析思想" class="headerlink" title="自顶向下的分析思想"></a>自顶向下的分析思想</h2><p>从分析树的顶部（根节点）向底部（叶节点）方向构造分析树，可以看成是从文法开始符号S推导出词串w的过程</p><h3 id="最左推导"><a href="#最左推导" class="headerlink" title="最左推导"></a>最左推导</h3><p>在最左推导中，总是选择每个句型的最左非终结符进行替换，即优先满足表达式左侧<br><img src="/image/notebook/Compilation-principle/leftmost-derivation.png" alt="最左推导"></p><h3 id="最右推导"><a href="#最右推导" class="headerlink" title="最右推导"></a>最右推导</h3><p>在最右推导中，总是选择每个句型的最右非终结符进行替换，即优先满足表达式右侧<br><img src="/image/notebook/Compilation-principle/rightmost-derivation.png" alt="最右推导"></p><p>自顶向下的语法分析采用最左推导方式</p><h3 id="预测分析"><a href="#预测分析" class="headerlink" title="预测分析"></a>预测分析</h3><ul><li>预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常是一个）符号来选择正确的A-产生式。</li><li>可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法有时也称为LL(k) 文法类</li><li>预测分析不需要回溯，是一种确定的自顶向下分析方法</li></ul><h2 id="文法转换"><a href="#文法转换" class="headerlink" title="文法转换"></a>文法转换</h2><h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><h4 id="直接左递归"><a href="#直接左递归" class="headerlink" title="直接左递归"></a>直接左递归</h4><p>当出现了类似如下的推导公式时</p><script type="math/tex; mode=display">A \rightarrow A \alpha | \beta</script><p>时，此时可以出现左递归的情况，这会导致无法正确的进行最左推导，因为可以出现下面的情况：</p><script type="math/tex; mode=display">A \Rightarrow A \alpha \Rightarrow A \alpha\alpha \Rightarrow A \alpha\alpha\alpha \Rightarrow A \alpha\alpha\alpha\alpha \dots</script><p>此时可以将上述的推导公式转换为</p><script type="math/tex; mode=display">\begin{cases}A \rightarrow \beta A' \\A' \rightarrow \alpha A' | \varepsilon\end{cases}</script><p>将左递归的公式转换为右递归即可</p><p>这样的操作的代价是</p><ul><li>引入了非终结符</li><li>$\varepsilon$ 产生式</li></ul><h4 id="间接左递归"><a href="#间接左递归" class="headerlink" title="间接左递归"></a>间接左递归</h4><p>例如</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow Aa | b \\A \rightarrow Sd | \varepsilon\end{cases}</script><p>此时可以产生这样的推导</p><script type="math/tex; mode=display">S \rightarrow Aa \rightarrow Sda \rightarrow Aada \rightarrow Sdada \dots</script><p>这时，应该将改为先进行替换得到</p><script type="math/tex; mode=display">A \rightarrow Aad | bd | \varepsilon</script><script type="math/tex; mode=display">\begin{cases}A \rightarrow bdA' | A' \\A' \rightarrow abA' | \varepsilon\end{cases}</script><h3 id="多个候选式"><a href="#多个候选式" class="headerlink" title="多个候选式"></a>多个候选式</h3><p>当出现</p><script type="math/tex; mode=display">S \rightarrow aAd | aBe</script><p>之类的结构，当读入的第一个字符为 $a$ 时，无法确定应该选择哪个产生式的时候，应该进行左公因子提取，即改编为</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow aS' \\S' \rightarrow Ad|Be\end{cases}</script><h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1) 文法"></a>LL(1) 文法</h2><h3 id="FIRST-集"><a href="#FIRST-集" class="headerlink" title="FIRST 集"></a>FIRST 集</h3><p>$FIRST(A)$ 集表示非终结符 $A$ 能够推导出的所有等式的第一个终结符的集合</p><script type="math/tex; mode=display">FIRST(\alpha) = \{ a | \alpha \Rightarrow a \beta, a \in V_T ， \alpha, \beta \in V^* \}</script><p>这条等式可以用下面三个原则来求算</p><p>对于一个产生式 $A \rightarrow B$而言</p><ul><li>若 $B$ 的第一个符号是终结符，则将此终结符加入到 $FIRST(A)$ 中</li><li>若 $B$ 的第一个符号是非终结符，则将此非终结符的 $FIRST$ 中除了 $\varepsilon$ 的加入到 $FIRST(A)$ 中</li><li>若 $B$ 的第一个符号是非终结符，它的 $FIRST$ 集中含有 $\varepsilon$ 则将下一个符号也进行这三条规则的判断，如果没有，下一个字符了，则将 $\varepsilon$ 加入到 $FIRST(A)$ 中</li></ul><h3 id="FOLLOW-集"><a href="#FOLLOW-集" class="headerlink" title="FOLLOW 集"></a>FOLLOW 集</h3><p>$FOLLOW(A)$ 集表示非终结符 $A$ 后可以跟随哪些终结符</p><script type="math/tex; mode=display">FOLLOW(A) = \{ a | S \Rightarrow^* \dots A a \dots，a \in V_T \}</script><script type="math/tex; mode=display">若 A \Rightarrow^* \dots A，则 \# \in FOLLOW(A)</script><p>这两条等式可以用下面三个原则来求算</p><ul><li>对于文法开始符号 $S$，则 <script type="math/tex">\# \in FOLLOW(S)</script></li><li>若存在类似 $B \rightarrow \alpha A \beta$ 的表达式，则 <script type="math/tex">FIRST(\beta) - \{\varepsilon\} \subseteq FOLLOW(A)</script></li><li>若存在类似 $B \rightarrow \alpha A$ 或者 $B \rightarrow \alpha A \beta 且 \beta \Rightarrow^* \varepsilon$，则 <script type="math/tex">FOLLOW(B) \subseteq FOLLOW(A)</script></li></ul><h3 id="SELECT-集"><a href="#SELECT-集" class="headerlink" title="SELECT 集"></a>SELECT 集</h3><p>表示使用某个产生式的选择符号</p><script type="math/tex; mode=display">\begin{cases}SELECT(A \rightarrow \alpha) = (FIRST(\alpha) - \{\varepsilon\}) \cup FOLLOW(A)，\alpha \Rightarrow^* \varepsilon \\SELECT(A \rightarrow \alpha) = FIRST(\alpha)，\alpha \not\Rightarrow^* \varepsilon\end{cases}</script><p>同时满足</p><script type="math/tex; mode=display">SELECT(A \rightarrow \alpha) \cap SELECT(A \rightarrow \beta) = \varnothing</script><h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>满足 LL(1) 的文法有下面三个条件：</p><p>若文法存在语句</p><script type="math/tex; mode=display">A \rightarrow \alpha | \beta</script><p>则</p><ul><li>不存在终结 $a$ 使得 $\alpha$ 和 $\beta$ 都能推导出以 $a$ 开头的串，即 $FIRST(\alpha) \cap FIRST(\beta) = \varnothing$</li><li>$\alpha$ 和 $\beta$ 至多有一个能推导出 $\varepsilon$</li><li>满足下面的等式</li></ul><script type="math/tex; mode=display">\begin{cases}FIRST(\alpha) \cap FOLLOW(A) = \varnothing, \beta \Rightarrow^* \varepsilon \\FIRST(\beta) \cap FOLLOW(A) = \varnothing, \alpha \Rightarrow^* \varepsilon\end{cases}</script><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><script type="math/tex; mode=display">对于所有的 A \rightarrow \alpha | \beta</script><p>若满足</p><script type="math/tex; mode=display">SELECT(A \rightarrow \alpha) \cap SELECT(A \rightarrow \beta) = \varnothing</script><p>则为 LL(1)</p><h3 id="非递归的预测分析法-表驱动的预测分析"><a href="#非递归的预测分析法-表驱动的预测分析" class="headerlink" title="非递归的预测分析法(表驱动的预测分析)"></a>非递归的预测分析法(表驱动的预测分析)</h3><p>首先需要根据 $SELECT$ 集来构建一个分析表。通过表的信息实现语法分析</p><h3 id="LL-1-文法分析示例"><a href="#LL-1-文法分析示例" class="headerlink" title="LL(1) 文法分析示例"></a>LL(1) 文法分析示例</h3><p>以下面的表达式文法为例</p><script type="math/tex; mode=display">\begin{cases}E \rightarrow E + T | T \\T \rightarrow T * F | F \\F \rightarrow i | (E)\end{cases}</script><h4 id="消除左递归-1"><a href="#消除左递归-1" class="headerlink" title="消除左递归"></a>消除左递归</h4><p>首先，消除左递归，易得，前两个式子均为左递归<br>得到</p><script type="math/tex; mode=display">\begin{cases}E \rightarrow TE' \\E' \rightarrow +TE' | \varepsilon \\T \rightarrow FT' \\T' \rightarrow *FT' | \varepsilon \\F \rightarrow i | (E)\end{cases}</script><h4 id="求出-FIRST"><a href="#求出-FIRST" class="headerlink" title="求出 FIRST"></a>求出 FIRST</h4><p>得到各个符号的 FIRST 集：</p><p>首先根据2、4、5式得到</p><script type="math/tex; mode=display">\begin{cases}FIRST(E') = \{+, \varepsilon\} \\FIRST(T') = \{*, \varepsilon\} \\FIRST(F) = \{i, (\}\end{cases}</script><p>然后根据 FIRST 集的求出剩下的 FIRST 集</p><script type="math/tex; mode=display">\begin{cases}FIRST(E) = \{i, ( \} \\FIRST(T) = \{i, ( \}\end{cases}</script><h4 id="求出-FOLLOW-集"><a href="#求出-FOLLOW-集" class="headerlink" title="求出 FOLLOW 集"></a>求出 FOLLOW 集</h4><p>然后再求出 FOLLOW 集</p><p>首先</p><script type="math/tex; mode=display">\# \in FOLLOW(E)</script><p>然后根据第一个等式得到</p><script type="math/tex; mode=display">FIRST(E') - \varepsilon \subseteq FOLLOW(T) \Rightarrow FOLLOW(T) = \{+\}</script><script type="math/tex; mode=display">FOLLOW(E) \subseteq FOLLOW(E') \Rightarrow FOLLOW(E') = \{\#\}</script><p>然后继续重复做，直到没有 FOLLOW 集发生更新为止，最终得到</p><script type="math/tex; mode=display">\begin{cases}FOLLOW(E) = \{ \#, ) \} \\FOLLOW(E') = \{ \#, ) \} \\FOLLOW(T) = \{ \#, +, )\} \\FOLLOW(T') = \{ \#, +, )\} \\FOLLOW(F) = \{ \#, +, ), *\}\end{cases}</script><h4 id="求出-SELECT-集"><a href="#求出-SELECT-集" class="headerlink" title="求出 SELECT 集"></a>求出 SELECT 集</h4><p>再得到 SELECT 集</p><script type="math/tex; mode=display">\begin{cases}SELECT(E \rightarrow TE') = FIRST(TE') = FIRST(T) = \{i, ( \} \\SELECT(E' \rightarrow +TE') = FIRST(+TE') = FIRST(+) = \{+\} \\SELECT(E' \rightarrow \varepsilon) = (FIRST(\varepsilon) - \{\varepsilon \}) \cup FOLLOW(E') = \{ \#, ) \} \\SELECT(T \rightarrow FT') = FIRST(FT') = FIRST(F) = \{i, (\} \\SELECT(T' \rightarrow * FT') = FIRST(*FT') = FIRST(*) = \{*\} \\SELECT(T' \rightarrow \varepsilon) = (FIRST(\varepsilon) - \{\varepsilon \}) \cup FOLLOW(T') = \{ \#, +, )\} \\SELECT(F \rightarrow i) = FIRST(i) = \{ i \} \\SELECT(F \rightarrow (E)) = FIRST((E)) = FIRST(() = \{ ( \} \\\end{cases}</script><p>此时，判断是否为 LL(1) 文法</p><script type="math/tex; mode=display">\begin{cases}SELECT(E' \rightarrow +TE') \cup SELECT(E' \rightarrow \varepsilon) = \varnothing \\SELECT(T' \rightarrow * FT') \cup SELECT(T' \rightarrow \varepsilon) = \varnothing \\SELECT(F \rightarrow i) \cup SELECT(F \rightarrow (E)) = \varnothing\end{cases}</script><p>所以是 LL(1)文法</p><h4 id="求出分析表"><a href="#求出分析表" class="headerlink" title="求出分析表"></a>求出分析表</h4><p>根据 SELECT 得出下表</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">i</th><th style="text-align:center">+</th><th style="text-align:center">*</th><th style="text-align:center">(</th><th style="text-align:center">)</th><th style="text-align:center">#</th></tr></thead><tbody><tr><td style="text-align:center">E</td><td style="text-align:center">$\rightarrow TE’$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow TE’$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">E’</td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow +TE’$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow \varepsilon$</td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr><tr><td style="text-align:center">T</td><td style="text-align:center">$\rightarrow FT’$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow FT’$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">T’</td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow \varepsilon$</td><td style="text-align:center">$\rightarrow *FT’$</td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow \varepsilon$</td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">$\rightarrow i$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow (E)$</td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="分析输入串"><a href="#分析输入串" class="headerlink" title="分析输入串"></a>分析输入串</h4><p>采用三列分析法来分析，使用 <code>#</code> 表示尾部，假设输入的串为 <code>i+i*i</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">剩余输入</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center"><code>E#</code></td><td style="text-align:center"><code>i+i*i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>TE&#39;#</code></td><td style="text-align:center"><code>i+i*i#</code></td><td style="text-align:center">匹配了表中的 $\rightarrow TE’$</td></tr><tr><td style="text-align:center"><code>FT&#39;E&#39;#</code></td><td style="text-align:center"><code>i+i*i#</code></td><td style="text-align:center">$\rightarrow FT’$</td></tr><tr><td style="text-align:center"><code>iT&#39;E&#39;#</code></td><td style="text-align:center"><code>i+i*i#</code></td><td style="text-align:center">$\rightarrow i$</td></tr><tr><td style="text-align:center"><code>T&#39;E&#39;#</code></td><td style="text-align:center"><code>+i*i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>E&#39;#</code></td><td style="text-align:center"><code>+i*i#</code></td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr><tr><td style="text-align:center"><code>+TE&#39;#</code></td><td style="text-align:center"><code>+i*i#</code></td><td style="text-align:center">$\rightarrow +TE’$</td></tr><tr><td style="text-align:center"><code>TE&#39;#</code></td><td style="text-align:center"><code>i*i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>FT&#39;E&#39;#</code></td><td style="text-align:center"><code>i*i#</code></td><td style="text-align:center">$\rightarrow FT’$</td></tr><tr><td style="text-align:center"><code>iT&#39;E&#39;#</code></td><td style="text-align:center"><code>i*i#</code></td><td style="text-align:center">$\rightarrow i$</td></tr><tr><td style="text-align:center"><code>T&#39;E&#39; #</code></td><td style="text-align:center"><code>*i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>*FT&#39;E&#39;#</code></td><td style="text-align:center"><code>*i#</code></td><td style="text-align:center">$\rightarrow *FT’$</td></tr><tr><td style="text-align:center"><code>FT&#39;E&#39;#</code></td><td style="text-align:center"><code>i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>iT&#39;E&#39;#</code></td><td style="text-align:center"><code>i#</code></td><td style="text-align:center">$\rightarrow i$</td></tr><tr><td style="text-align:center"><code>T&#39;E&#39;#</code></td><td style="text-align:center"><code>#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>E&#39;#</code></td><td style="text-align:center"><code>#</code></td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr><tr><td style="text-align:center"><code>#</code></td><td style="text-align:center"><code>#</code></td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr></tbody></table></div><p>匹配成功</p><h2 id="LL-1-分析中的出错处理"><a href="#LL-1-分析中的出错处理" class="headerlink" title="LL(1) 分析中的出错处理"></a>LL(1) 分析中的出错处理</h2><p>略</p><h1 id="自底向上优先分析"><a href="#自底向上优先分析" class="headerlink" title="自底向上优先分析"></a>自底向上优先分析</h1><h2 id="自底向下的分析思想"><a href="#自底向下的分析思想" class="headerlink" title="自底向下的分析思想"></a>自底向下的分析思想</h2><p>从分析树的底部(叶节点)向顶部(根节点)方向构造分析树，可以看成是将输入串w归约为文法开始符号S的过程，自底向上的语法分析采用最左归约方式（反向构造最右推导）</p><h1 id="LR-0-和-SLR-1-分析法"><a href="#LR-0-和-SLR-1-分析法" class="headerlink" title="LR(0) 和 SLR(1) 分析法"></a>LR(0) 和 SLR(1) 分析法</h1><ul><li>L: 对输入进行从左到右的扫描</li><li>R: 反向构造出一个最右推导序列</li></ul><p><strong><font color=red>由于 SLR(1) 的操作和 LR(0) 分析法相似，且兼容，所以这里直接写 SLR(1) 的操作过程，LR(0) 文法也可以直接用此方法，得到的结果完全相同</font></strong></p><p>以此文法为例</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow L*L | L \\L \rightarrow LB | B \\B \rightarrow 0 | 1\end{cases}</script><h2 id="构造分析表"><a href="#构造分析表" class="headerlink" title="构造分析表"></a>构造分析表</h2><h3 id="将所有的或运算式子转换为多个式子"><a href="#将所有的或运算式子转换为多个式子" class="headerlink" title="将所有的或运算式子转换为多个式子"></a>将所有的或运算式子转换为多个式子</h3><p>得到</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow L*L \\S \rightarrow L \\L \rightarrow LB \\L \rightarrow B \\B \rightarrow 0 \\B \rightarrow 1\end{cases}</script><h3 id="合并相同开始符号"><a href="#合并相同开始符号" class="headerlink" title="合并相同开始符号"></a>合并相同开始符号</h3><p>LR分析法不适用于有多个开始符号的产生式，所以应当对上面的产生式进行处理得到</p><script type="math/tex; mode=display">\begin{cases} 0) S' \rightarrow S \\ 1) S \rightarrow L*L \\ 2) S \rightarrow L \\ 3) L \rightarrow LB \\ 4) L \rightarrow B \\ 5) B \rightarrow 0 \\ 6) B \rightarrow 1\end{cases}</script><p><em>每行开头的为编号，后续通过编号来指代产生式</em></p><h3 id="建立状态"><a href="#建立状态" class="headerlink" title="建立状态"></a>建立状态</h3><p>对于一个状态，首先，判断<code>.</code>后面是否为非终结符号。如果是，那我们就得找所有由此非终结符推出的产生式，并将它们添加进入此状态里。循环做即可。</p><p><em>使用 <code>.</code> 表示当前匹配到的位置</em></p><p>首先建立初状态，将第一个表达式加入初状态 State 0</p><h4 id="State-0"><a href="#State-0" class="headerlink" title="State 0"></a>State 0</h4><p>此状态中有 $S’ \rightarrow .S$</p><p>检查 <code>.</code> 后是否为非终结符，得到 $S$，由于 $S$ 是非终结符，所以将 $S$ 的产生式加入此状态得到</p><script type="math/tex; mode=display">\begin{cases}S' \rightarrow .S \\S \rightarrow .L*L \\S \rightarrow .L \\\end{cases}</script><p>再检查新加入的，得到 $L$ 也需要加入此状态</p><script type="math/tex; mode=display">\begin{cases}S' \rightarrow .S \\S \rightarrow .L*L \\S \rightarrow .L \\L \rightarrow .LB \\L \rightarrow .B \\\end{cases}</script><p>最后发现 $B$ 也是需要加入此状态的得到 State 0 的最终结果</p><script type="math/tex; mode=display">\begin{cases}S' \rightarrow .S \\S \rightarrow .L*L \\S \rightarrow .L \\L \rightarrow .LB \\L \rightarrow .B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><p>接下来的每个状态都是从 State 转换过来的，即将小数点向后移动，可以得到不同的状态<br>根据其状态内的产生式，可以得到 State 0 可以有 $S, L, B, 0, 1$ 这五个转移方式</p><h4 id="State-1"><a href="#State-1" class="headerlink" title="State 1"></a>State 1</h4><p>设定 State 1 是从 State 0 通过 $S$ 转移过来的</p><p>所以可以得到，仅</p><script type="math/tex; mode=display">S' \rightarrow S.</script><p>满足，所以 State 1 即只有此产生式，且不可以再转移</p><p>注意，State 1 是第一个产生式的最后的结果，所以此状态作为 <code>Accept</code> 状态，简称 <code>acc</code></p><h4 id="State-2"><a href="#State-2" class="headerlink" title="State 2"></a>State 2</h4><p>设定 State 2 是从 State 0 通过 $L$ 转移过来</p><p>所以可以直接得到的有</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow L.*L \\S \rightarrow L. \\L \rightarrow L.B \\\end{cases}</script><p>对于第三个式子，其满足条件(<code>.</code>后为非终结符)，所以需要把 $B$ 加入此状态</p><p>即得到</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow L.*L \\S \rightarrow L. \\L \rightarrow L.B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><h4 id="其他-State"><a href="#其他-State" class="headerlink" title="其他 State"></a>其他 State</h4><p>不断重复上述步骤，得到下面的图和结果</p><script type="math/tex; mode=display">State 0 = \begin{cases}S' \rightarrow .S \\S \rightarrow .L*L \\S \rightarrow .L \\L \rightarrow .LB \\L \rightarrow .B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><script type="math/tex; mode=display">State 1 =\begin{cases}S' \rightarrow S.\end{cases}</script><script type="math/tex; mode=display">State 2 =\begin{cases}S \rightarrow L.*L \\S \rightarrow L. \\L \rightarrow L.B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><script type="math/tex; mode=display">State 3 =\begin{cases}L \rightarrow B.\end{cases}</script><script type="math/tex; mode=display">State 4 =\begin{cases}B \rightarrow 0.\end{cases}</script><script type="math/tex; mode=display">State 5 =\begin{cases}B \rightarrow 1.\end{cases}</script><script type="math/tex; mode=display">State 6 =\begin{cases}S \rightarrow L*.L \\L \rightarrow .LB \\L \rightarrow .B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><script type="math/tex; mode=display">State 7 =\begin{cases}L \rightarrow LB.\end{cases}</script><script type="math/tex; mode=display">State 8 =\begin{cases}S \rightarrow L*L. \\L \rightarrow L.B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><pre><code class=" mermaid">graph LRA[State 0] -- S --&gt; B[State 1]A[State 0] -- L --&gt; C[State 2]A[State 0] -- B --&gt; D[State 3]A[State 0] -- 0 --&gt; E[State 4]A[State 0] -- 1 --&gt; F[State 5]C[State 2] -- * --&gt; G[State 6]C[State 2] -- B --&gt; H[State 7]C[State 2] -- 0 --&gt; E[State 4]C[State 2] -- 1 --&gt; F[State 5]G[State 6] -- L --&gt; I[State 8]G[State 6] -- B --&gt; D[State 3]G[State 6] -- 0 --&gt; E[State 4]G[State 6] -- 1 --&gt; F[State 5]I[State 8] -- B --&gt; H[State 7]I[State 8] -- 0 --&gt; E[State 4]I[State 8] -- 1 --&gt; F[State 5]B[State 1] --&gt; Accept([Accept])</code></pre><p><em>Accept通常状态不需要画出</em></p><h3 id="创建LR分析表"><a href="#创建LR分析表" class="headerlink" title="创建LR分析表"></a>创建LR分析表</h3><p>由此图和上面的集合可以画出表格</p><table border="0" cellpadding="0" cellspacing="0" width="576" style="border-collapse:  collapse;table-layout:fixed;width:432pt">    <colgroup>        <col class="x22" width="72" span="8" style="mso-width-source:userset;width:54pt">    </colgroup>    <tbody>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r0">            <td rowspan="2" height="38" class="x21" width="72" style="height:28.5pt;width:54pt;">状态</td>            <td colspan="4" class="x21" width="288">ACTION</td>            <td colspan="3" class="x21" width="216">GOTO</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r1">            <td class="x22">0</td>            <td class="x22">1</td>            <td class="x22">*</td>            <td class="x22">$</td>            <td class="x22">S</td>            <td class="x22">L</td>            <td class="x22">B</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r2">            <td height="19" class="x22" style="height:14.25pt;">0</td>            <td class="x22">s4</td>            <td class="x22">s5</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">1</td>            <td class="x22">2</td>            <td class="x22">3</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r3">            <td height="19" class="x22" style="height:14.25pt;">1</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">acc</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r4">            <td height="19" class="x22" style="height:14.25pt;">2</td>            <td class="x22">s4</td>            <td class="x22">s5</td>            <td class="x22">s6</td>            <td class="x22">r2</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">7</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r5">            <td height="19" class="x22" style="height:14.25pt;">3</td>            <td class="x22">r4</td>            <td class="x22">r4</td>            <td class="x22">r4</td>            <td class="x22">r4</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r6">            <td height="19" class="x22" style="height:14.25pt;">4</td>            <td class="x22">r5</td>            <td class="x22">r5</td>            <td class="x22">r5</td>            <td class="x22">r5</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r7">            <td height="19" class="x22" style="height:14.25pt;">5</td>            <td class="x22">r6</td>            <td class="x22">r6</td>            <td class="x22">r6</td>            <td class="x22">r6</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r8">            <td height="19" class="x22" style="height:14.25pt;">6</td>            <td class="x22">s4</td>            <td class="x22">s5</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">8</td>            <td class="x22">3</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r9">            <td height="19" class="x22" style="height:14.25pt;">7</td>            <td class="x22">r3</td>            <td class="x22">r3</td>            <td class="x22">r3</td>            <td class="x22">r3</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r10">            <td height="19" class="x22" style="height:14.25pt;">8</td>            <td class="x22">s4</td>            <td class="x22">s5</td>            <td class="x22"></td>            <td class="x22">r1</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">7</td>        </tr>        <!--[if supportMisalignedColumns]-->        <tr height="0" style="display:none">            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>        </tr>        <!--[endif]-->    </tbody></table><p>表的构建原则：</p><ul><li>首先，表头分为两列，ACTION 和 GOTO，在 ACTION 下均为终结符，而在 GOTO 下均为非终结符，其中在 ACTION 下还需要加上 <code>$</code> 状态标识匹配结束符(在LL(1)文法中，使用了 <code>#</code> 作为结束符，实际上两种方法均可作为结束符，只需要在题目中注明即可)</li><li>对于每一个状态，如果它在图中存在任何转移的方向，则将此转移方向填入表格中。如果转移状态为非终结符，则直接填入对应状态的序号，如果为终结符，则格式为 <code>sn</code> 其中 <code>n</code> 为转移的目标状态<ul><li>以图中 State 0 为例，其可以通过 $B$ 转移至 State 3，而 $B$ 是一个非终结符，所以在状态为 0 的那一行的第 $B$ 类填上 <code>3</code> 即可</li><li>以图中 State 0 为例，其可以通过 $0$ 转移至 State 4，所以在状态为 0 的那一行的第 $0$ 列填上 <code>s4</code></li></ul></li><li>若此状态中存在任何一个产生式满足 <code>.</code> 在此产生式的最后<ul><li>假定此状态内的等式有两类，则进行如下操作(此时可以确定，此文法不可能为 LR(0)，但是可以是SLR(1))<blockquote><p>既有满足条件的，又有不满足条件的时候</p><script type="math/tex; mode=display">\begin{cases}A_1 \rightarrow \alpha_1 . a_1 \beta_1 \\A_2 \rightarrow \alpha_2 . a_2 \beta_2 \\\dots \\B_1 \rightarrow \gamma_1 . \\B_2 \rightarrow \gamma_2 . \\\dots\end{cases}</script><p>显然，前面的产生式为不满足条件的产生式，后面的产生式均为满足条件的产生式<br>若均满足下列条件，则认为可以通过 SLR 分析法处理，否则认为不可解</p><script type="math/tex; mode=display">\begin{cases}\forall FOLLOW(B_i) \cap \{a_1, a_2 \dots \}  = \varnothing \\\forall FOLLOW(B_i) \cap \forall FOLLOW(B_j) = \varnothing \end{cases}</script><p>若满足上述条件，则对于 <code>ACTION</code> 列中的每一项 $a$<br>若 $a \in {a_1, a_2 \dots }$，则采用 <code>sn</code> 的标识方式，即<br>若 $a \in FOLLOW(B_i)$，则在所在列标注上 <code>rn</code>，其中 <code>n</code> 指代第几号产生式，这条产生式为 $B_i \rightarrow \gamma_i$</p></blockquote></li><li>若此状态内的等式只有一类，即只有满足条件的，则在其所有的 ACTION 列中用 <code>rn</code> 标注(若只有此条件的状态，则此时可以称文法为 LR(0) 文法)<blockquote><p>以 State 2 为例，有四个式子不满足条件，仅一个式子满足条件。其中 $S \rightarrow L.$ 为满足条件的式子，剩下四个均不满足条件。所以我们先求出 $S$ 的 <script type="math/tex">FOLLOW(S) = \{\$\}</script>，满足等式 <script type="math/tex">FOLLOW(S) \cap \{*, B, 0, 1\} = \varnothing</script><br>接着遍历所有 <code>ACTION</code> 内的符号，对于 $0$ 而言，其属于 <script type="math/tex">\{*, B, 0, 1\}</script> 所以，写入 <code>s4</code><br>对于 $\$$ 而言，其属于 FOLLOW(S)，所以写上 $S \rightarrow L$ 这个产生对应的序号，即 <code>r2</code></p></blockquote></li></ul></li></ul><!-- ## LR(1) 和 LALR(1)提出了后继符号概念定义每一个产生式应当描述为$$A \rightarrow \alpha . \beta, a$$其中，前半部分为普通的产生式，后面紧跟一个<font color=red>展望符</font>。其表示 $A$ 后面必须紧跟的终结符，其通常是 FOLLOW(A) 的真子集。 - LR(1) 中的 1 表示的即为此展望符的长度 - 当 $\beta \neq \varepsilon$ 时，此展望符没有任何作用 - 当 $\beta = \varepsilon$ 时，当且仅当下一个符号属于 $a$ 时，才可以用此产生式进行规约 - 若存在 $B \rightarrow \gamma$ 则其展望符为 $FIRST(\beta a)$，当 $\beta \Rightarrow^* \varepsilon$ 时，此时展望符为 $a$此时，再进行类似 LL(0) 文法的分析操作，以下面的文法为例$$\begin{cases}S \rightarrow L=R | R \\L \rightarrow *R | id \\R \rightarrow L\end{cases}$$此处省略过程，直接得到答案### 处理后的产生式为$$\begin{cases} 0) S' \rightarrow S \\ 1) S \rightarrow L=R \\ 2) S \rightarrow R \\ 3) L \rightarrow *R \\ 4) L \rightarrow id \\ 5) R \rightarrow L\end{cases}$$### 每个状态的产生式为$$State 0\begin{cases}S' \rightarrow .S, \$ \\S \rightarrow .L=R, \$ \\S \rightarrow .R, \$ \\L \rightarrow .*R, =/\$ \\L \rightarrow .id, =/\$ \\R \rightarrow .L, =/\$\end{cases}$$$$State 1\begin{cases}S' \rightarrow S.,\$\end{cases}$$$$State 2\begin{cases}S \rightarrow L.=R,\$ \\R \rightarrow L.,\$\end{cases}$$$$State 3\begin{cases}S \rightarrow R.,\$\end{cases}$$$$State 4\begin{cases}L \rightarrow *.R,=/\$ \\R \rightarrow .L, =/\$ \\L \rightarrow .*R, =/\$ \\L \rightarrow .id, =/\$\end{cases}$$$$State 4\begin{cases}S \rightarrow L=.R,\$ \\R \rightarrow .L, \$ \\L \rightarrow .*R, \$ \\L \rightarrow .id, \$\end{cases}$$ --><h1 id="LR-1-和-LALR-1"><a href="#LR-1-和-LALR-1" class="headerlink" title="LR(1) 和 LALR(1)"></a>LR(1) 和 LALR(1)</h1><p>略</p><h1 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h1><p>即将上面的那些产生式带入实际的使用中</p><p>例如可以通过下面的文法来描述 <code>C</code> 语言的定义一个变量的过程</p><div class="table-container"><table><thead><tr><th style="text-align:center">产生式</th><th style="text-align:center">语义规则</th></tr></thead><tbody><tr><td style="text-align:center">$S \rightarrow TL$</td><td style="text-align:center">L的类型为T</td></tr><tr><td style="text-align:center">$T \rightarrow int$</td><td style="text-align:center">T为int</td></tr><tr><td style="text-align:center">$T \rightarrow double$</td><td style="text-align:center">T为double</td></tr><tr><td style="text-align:center">$L \rightarrow L, id$</td><td style="text-align:center">创建一个新的 <script type="math/tex">L_{右}</script>，将其类型设置为 <script type="math/tex">L_{左}</script> 相同的类型。并创建一个变量，其类型为 <script type="math/tex">L_{左}</script> 的类型，名字为 <script type="math/tex">id</script></td></tr><tr><td style="text-align:center">$L \rightarrow id$</td><td style="text-align:center">创建一个变量，其类型为 <script type="math/tex">L_{左}</script> 的类型，名字为 <script type="math/tex">id</script></td></tr></tbody></table></div><p>改为用属性来描述，则可以得到如下表格</p><div class="table-container"><table><thead><tr><th style="text-align:center">产生式</th><th style="text-align:center">语义规则</th></tr></thead><tbody><tr><td style="text-align:center">$S \rightarrow TL$</td><td style="text-align:center"><code>L.type = T.type</code></td></tr><tr><td style="text-align:center">$T \rightarrow int$</td><td style="text-align:center"><code>T.type = int</code></td></tr><tr><td style="text-align:center">$T \rightarrow double$</td><td style="text-align:center"><code>T.type = double</code></td></tr><tr><td style="text-align:center">$L \rightarrow L, id$</td><td style="text-align:center"><code>L(右).type = L.type</code><br><code>CreateVar(type = L.type, name = id.name)</code></td></tr><tr><td style="text-align:center">$L \rightarrow id$</td><td style="text-align:center"><code>CreateVar(type = L.type, name = id.name)</code></td></tr></tbody></table></div><ul><li>语法制导定义(SDD)</li><li>语法制导翻译方案(SDT)</li></ul><h2 id="SDD-语法制导定义"><a href="#SDD-语法制导定义" class="headerlink" title="SDD(语法制导定义)"></a>SDD(语法制导定义)</h2><h3 id="综合属性和继承属性"><a href="#综合属性和继承属性" class="headerlink" title="综合属性和继承属性"></a>综合属性和继承属性</h3><p>对于一个产生式产生的语义规则中，如果产生式左部的属性是仅通过右部的属性得到的，则称此属性为<font color=red>综合属性</font>。而如果产生式右部的属性是通过右部的属性或者左部的属性得到的，则称为<font color=red>继承属性</font></p><p><img src="/image/notebook/Compilation-principle/L-SDD.png" alt="L-SDD"></p><h3 id="S-属性定义-与-L-属性定义"><a href="#S-属性定义-与-L-属性定义" class="headerlink" title="S-属性定义 与 L-属性定义"></a>S-属性定义 与 L-属性定义</h3><h4 id="S-属性文法"><a href="#S-属性文法" class="headerlink" title="S-属性文法"></a>S-属性文法</h4><p>仅仅使用综合属性的SDD称为S属性的SDD，或S-属性定义、S-SDD</p><h4 id="L-属性文法"><a href="#L-属性文法" class="headerlink" title="L-属性文法"></a>L-属性文法</h4><p>一个SDD是L-属性定义(L-SDD)，当且仅当它的每个属性要么是一个综合属性，要么是满足如下条件的继承属性：假如存在一个产生式 $A \rightarrow X_1 X_2 X_3 \dots$，若存在一个 $X_i$，它的一个属性值与下面的有关</p><ul><li>$A$ 的继承属性</li><li>来自 <script type="math/tex">X_1, X_2, X_3, \dots , X_{i-1}</script> 的属性</li><li>$X_i$ 自身的属性，但不能形成死循环</li></ul><p>例如上面的图片即为 L-SDD</p><h2 id="SDT-语法制导翻译方案"><a href="#SDT-语法制导翻译方案" class="headerlink" title="SDT(语法制导翻译方案)"></a>SDT(语法制导翻译方案)</h2><p>语法制导翻译方案(SDT)是在产生式右部中嵌入了程序片段(称为语义动作)的CFG(上下文无关文法)</p><p>例如</p><script type="math/tex; mode=display">\begin{cases}D \rightarrow T \{L.type = T.type \} L \\T \rightarrow int \{T.type = int \} \\T \rightarrow double \{T.type = double \} \\L \rightarrow \{ L_1.type = L.type \} L_1, id\end{cases}</script><p>嵌入规则如下</p><ul><li>将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上</li><li>将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端</li></ul><p>使用时，当在进行规约操作时，需要同时执行此程序片段</p><h1 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h1><h2 id="中间代码举例"><a href="#中间代码举例" class="headerlink" title="中间代码举例"></a>中间代码举例</h2><ul><li>AST，抽象语法树</li><li>TAC，三地址码，四元式</li><li>P-code，特别用于 Pasal 语言实现</li><li>Bytecode，Java 编译器的输出</li><li>SSA，静态单赋值形式</li></ul><h2 id="典型语句的翻译-四元式"><a href="#典型语句的翻译-四元式" class="headerlink" title="典型语句的翻译(四元式)"></a>典型语句的翻译(四元式)</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x = b * (c + d) + a<br></code></pre></td></tr></table></figure><ol><li><code>(+, c, d, t1)</code></li><li><code>(*, b, t1, t2)</code></li><li><code>(+, t2, a, t3)</code></li><li><code>(=, t3,  , x)</code></li></ol><h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a &gt; b) &amp;&amp; (c &lt; d) || (e &lt; f) &amp;&amp; (!g)<br></code></pre></td></tr></table></figure><ol><li><code>(j&gt;, a, b, 3)</code></li><li><code>(j, , ,5)</code></li><li><code>(j&lt;, c, d, true)</code></li><li><code>(j, , , 5)</code></li><li><code>(j&lt;, e, f, 7)</code></li><li><code>(j, , , false)</code></li><li><code>(jnz, g, , true)</code></li><li><code>(j, , , false)</code></li></ol><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) x = x + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x = <span class="hljs-number">4</span> * (x - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ol><li><code>(j&gt;, a, 0, 3)</code></li><li><code>(j, , , 6)</code></li><li><code>(+, x, 1, t1)</code></li><li><code>(=, t1, , x)</code></li><li><code>(j, , , 9)</code></li><li><code>(-, x, 1, t2)</code></li><li><code>(*, 4, t2, t3)</code></li><li><code>(=, t3, , x)</code></li><li></li></ol><h1 id="运行存储分配"><a href="#运行存储分配" class="headerlink" title="运行存储分配"></a>运行存储分配</h1><ul><li>对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的分配策略称为<font color=red>静态存储分配</font></li><li>反之，如果不能在编译时完全确定数据对象的大小，就要采用<font color=red>动态存储分配</font>的策略。即在编译时仅产生各种必要的信息，而在运行时刻，再动态地分配数据对象的存储空间</li></ul><p><img src="/image/notebook/Compilation-principle/memory.png" alt="memory"></p><ul><li>使用过程(或函数、方法)作为用户自定义动作的单元的语言，其编译器通常以过程为单位分配存储空间</li><li>过程体的每次执行称为该过程的一个<font color=red>活动</font>(activation)</li><li>过程每执行一次，就为它分配一块连续存储区，用来管理过程一次执行所需的信息，这块连续存储区称为<font color=red>活动记录</font>(activation record)</li></ul><h2 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h2><ul><li>静态存储分配中，由编译器决定其在程序中的位置，每次运行时，其位置都相同</li><li>限制条件<ul><li>数组上下界均为常数</li><li>不允许过程的递归调用</li><li>不允许动态建立数据实体</li></ul></li></ul><h3 id="顺序分配法"><a href="#顺序分配法" class="headerlink" title="顺序分配法"></a>顺序分配法</h3><p>为每个静态过程都逐段分配存储空间，每个过程的内存空间都相互独立且不相交</p><p>优点：处理上简单<br>缺点：对内存空间的使用不够经济合理</p><h3 id="层次分配法"><a href="#层次分配法" class="headerlink" title="层次分配法"></a>层次分配法</h3><p>通过对过程间的调用关系进行分析，凡属无相互调用关系的并列过程，尽量使其局部数据<font color=red>共享</font>存储空间</p><h2 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h2><p>将内存认为是一个栈空间</p><p>当一个过程被调用时，向栈中推入一个活动记录，当此过程结束时，该记录被弹出栈</p><h2 id="活动树"><a href="#活动树" class="headerlink" title="活动树"></a>活动树</h2><p>用来描述程序运行期间控制进入和离开各个活动的情况的树称为活动树。在表示过程 p 的某个活动的结点上，其子结点对应于被 p的这次活动调用的各个过程的活动。按照这些活动被调用的顺序，自左向右地显示它们。一个子结点必须在其右兄弟结点的活动开始之前结束</p><h2 id="调用序列和返回序列"><a href="#调用序列和返回序列" class="headerlink" title="调用序列和返回序列"></a>调用序列和返回序列</h2><p>暂略</p><h2 id="非局部数据的访问"><a href="#非局部数据的访问" class="headerlink" title="非局部数据的访问"></a>非局部数据的访问</h2><p>暂略</p><h2 id="堆式存储分配"><a href="#堆式存储分配" class="headerlink" title="堆式存储分配"></a>堆式存储分配</h2><p>暂略</p><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>暂略</p><h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><h2 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h2><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><ul><li>控制流只能从基本块的第一个指令进入该块。也就是说，没有跳转到基本块中间或末尾指令的转移指令</li><li>除了基本块的最后一个指令，控制流在离开基本块之前不会跳转或者停机</li></ul><p>划分方法：</p><ul><li>确定首指令<ul><li>第一个指令是首指令</li><li>任何一个条件或无条件转移的指令的目标指令是一个首指令</li><li>紧跟在一个条件或无条件转移指令之后的指令是一个首指令</li></ul></li><li>任意两个相邻的首指令之间的记为一个基本块</li></ul><p>例如对于代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i = m - <span class="hljs-number">1</span>;<br>j = n;<br>v = a[n];<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">do</span> i = i + <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(a[i] &lt; v);<br>    <span class="hljs-keyword">do</span> j = j - <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(a[j] &gt; v);<br>    <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>;<br>    x = a[i];<br>    a[i] = a[j];<br>    a[j] = x;<br>&#125;<br>x = a[i];<br>a[i] = a[n];<br>a[n] = x;<br></code></pre></td></tr></table></figure><p>可以划分出 6 个基本块</p><p>B1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i = m - <span class="hljs-number">1</span>;<br>j = n;<br>v = a[n];<br></code></pre></td></tr></table></figure><br>B2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i = i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> a[i] &lt; v <span class="hljs-keyword">goto</span> B2<br></code></pre></td></tr></table></figure><br>B3:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">j = j - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> a[j] &gt; v <span class="hljs-keyword">goto</span> B3<br></code></pre></td></tr></table></figure><br>B4:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> i &gt;= j <span class="hljs-keyword">goto</span> B6<br></code></pre></td></tr></table></figure><br>B5:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x = a[i];<br>a[i] = a[j];<br>a[j] = x;<br><span class="hljs-keyword">goto</span> B2<br></code></pre></td></tr></table></figure><br>B6:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x = a[i];<br>a[i] = a[n];<br>a[n] = x;<br></code></pre></td></tr></table></figure></p><h3 id="流图-1"><a href="#流图-1" class="headerlink" title="流图"></a>流图</h3><p>根据上面的基本块，再根据其转跳关系，可以绘制流图<br><pre><code class=" mermaid">graph LRB1 --&gt; B2B2 --&gt; B2B2 --&gt; B3B3 --&gt; B3B3 --&gt; B4B4 --&gt; B5B4 --&gt; B6B5 --&gt; B2</code></pre></p><h2 id="常用的代码优化方法"><a href="#常用的代码优化方法" class="headerlink" title="常用的代码优化方法"></a>常用的代码优化方法</h2><p>暂略</p><h2 id="基本块的优化"><a href="#基本块的优化" class="headerlink" title="基本块的优化"></a>基本块的优化</h2><p>将基本块通过 DAG(有向无环图) 表示</p><p>例如对于代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a = b + c;<br>b = b - d;<br>c = c + d;<br>e = b + c;<br></code></pre></td></tr></table></figure><p>可以绘制出如下的 DAG 图(通常在图上标注运算符号而不是字母，这里为了更容易理解标注了字母)</p><pre><code class=" mermaid">graph LRb0((b)) --&gt; a0((a))c0((c)) --&gt; a0((a))b0((b)) --&gt; b1((b))d0((d)) --&gt; b1((b))c0((c)) --&gt; c1((c))d0((d)) --&gt; c1((c))c1((c)) --&gt; e0((e))b1((b)) --&gt; e0((e))</code></pre><p>若结果 <code>e</code> 是需要返回的值，即其他基本块需要使用的值，则通过 DAG 图可知，变量 <code>a</code> 是无用的，可以删除</p><p>得到新的图为<br><pre><code class=" mermaid">graph LRb0((b)) --&gt; b1((b))d0((d)) --&gt; b1((b))c0((c)) --&gt; c1((c))d0((d)) --&gt; c1((c))c1((c)) --&gt; e0((e))b1((b)) --&gt; e0((e))</code></pre><br>所以可以得到优化后的代码为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">b = b - d;<br>c = c + d;<br>e = b + c;<br></code></pre></td></tr></table></figure></p><h2 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h2><p>略</p><h2 id="到达定值分析"><a href="#到达定值分析" class="headerlink" title="到达定值分析"></a>到达定值分析</h2><p>暂略</p><h2 id="代码优化技术"><a href="#代码优化技术" class="headerlink" title="代码优化技术"></a>代码优化技术</h2><ul><li>依优化范围划分<ul><li>窥孔优化：局部的几条指令范围内的优化</li><li>局部优化：基本块范围内的优化</li><li>全局优化：流图范围内的优化</li><li>过程间优化：整个程序范围内的优化</li></ul></li><li>依优化对象划分<ul><li>目标代码优化：面向代码优化</li><li>中间代码优化：面向程序的中间表示</li><li>源级优化：面向源程序</li></ul></li><li>依优化侧面划分<ul><li>指令调度</li><li>寄存器分配</li><li>存储层次优化</li><li>存储布局优化</li><li>循环优化</li><li>控制流优化</li><li>过程优化</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>课程</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2021/01/07/notebook/Computer-network/"/>
    <url>/2021/01/07/notebook/Computer-network/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>21世纪的重要特征是：数字化、网络化、信息化，以网络为核心的信息时代</li><li>三类网络：电信网络、有线电视网络、计算机网络</li><li>互联网的特点：连通性和共享<ul><li>连通性：互联网使得上网用户之间，不管相距多远，都可以非常便捷、非常经济地交换信息</li><li>共享：信息共享、软件共享、硬件共享</li></ul></li></ul><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><ul><li>计算机网络由若干结点(node)和连接这些结点的链路(link)组成</li><li>internet 是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络</li><li>Internet 是一个专有名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET</li><li>互联网的三个阶段<ul><li>从单个网络 ARPANET 向互连网发展的过程，TCP/IP 协议成为 ARPANET 上的标准协议</li><li>建成了三级结构的互联网，分为主干网、地区网、校园网(企业网)</li><li>形成了多层次 ISP 结构的互联网</li></ul></li><li>ISP：网络服务提供商，例如中国电信<ul><li>ISP分为不同的层次：主干 ISP、地区 ISP、本地 ISP</li><li>主干 ISP 服务面积大，拥有高速主干网</li><li>地区 ISP 通过一个或多个主干 ISP 连接起来，部分大公司直接接入地区 ISP</li><li>本地 ISP 负责给用户提供直接的服务，用户数据经由本地 ISP、地区 ISP、主干 ISP、地区 ISP、本地 ISP 发送至目标用户</li></ul></li><li>IXP：互联网交换点，将两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。使得互联网上的数据流量分布更加合理，减少了分组转发的迟延时间，降低了分组转发的费用</li></ul><p><img src="/image/notebook/Computer-network/1.png" alt="ISP"></p><ul><li>万维网(WWW)被广泛使用在互联网上，大大方便广大非网络专业人员对网络的使用</li><li>互联网的标准化工作由互联网协会(ISOC)进行管理<ul><li>互联网体系结构委员会(IAB)：负责管理互联网有关协议的开发<ul><li>互联网工程部(IETF)</li><li>互联网研究部(IRTF)</li></ul></li></ul></li></ul><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><ul><li>边缘部分：由所有连接在互联网上的主机(端系统 end system)组成。这部分是用户直接使用的，用来进行通信和资源共享</li><li>核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的</li></ul><h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><p>互联网的<font color=red>通信方式</font>：</p><ul><li>客户(Client)-服务器(Server)(C/S方式)：主机A运行客户程序而主机B运行服务器程序，在这种情况下，A是客户而B是服务器。客户A向服务器发出服务请求，而服务器B向客户A提供服务。<font color=red>客户是服务请求方，而服务器是服务提供方</font>。</li><li>对等方式(P2P方式 peer-to-peer)：两台主机都运行了对等连接软件(P2P软件)，他们可以进行平等的、对等连接通信</li></ul><h3 id="互联网的核心部分-通信交换方式"><a href="#互联网的核心部分-通信交换方式" class="headerlink" title="互联网的核心部分(通信交换方式)"></a>互联网的核心部分(通信交换方式)</h3><p>在互联网核心部分起特殊作用的是路由器。路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>使用电路交换通话之前，必须先拨号请求连接。当被叫用户听到交换机振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条专用的物理通路。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。<font color=red>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</font>。以下三个步骤称为电路交换</p><ul><li>建立连接(占用通信资源)</li><li>通话(一直占用通信资源)</li><li>释放资源(归还通信资源)</li></ul><p>如果用户在拨号呼叫时电信网的资源已不足以支持此次呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫(例如对方正在通话中)</p><p>但使用电路交换来传送计算机数据时，其<strong>线路的的传输效率往往很低</strong>。这是因为计算机的数据是突发式地出现在传输线路上的，因此线路上真正用来传送的数据时间往往不到10%，甚至1%。浪费通信线路资源</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>分组交换采用存储转发技术，我们把要发送的整块数据称为一个报文(message)，在发送端，先把较长的报文划分成较短的、固定长度的数据段，每一个数据段前面添加上首部(header)构成分组(packet)。分组又称为包，分组的首部也可以称为包头。以下三个步骤</p><ul><li>路由器/交换机接受数据包(存储)</li><li>路由器/交换机查看数据段的首部，决定数据包接下来应该发送给哪个路由器</li><li>路由器/交换机发送数据包(转发)</li></ul><p>优点：</p><ul><li>高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</li><li>灵活：为每一个分组独立地选择最合适的转发路由</li><li>迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠的网络协议，分布式多路由的分组交换网，使网络有很好的生存性</li></ul><p>缺点：</p><ul><li>分组在各路由器存储转发时需要排队，会造成一定的时延</li><li>分组交换需要携带控制信息</li></ul><p><img src="/image/notebook/Computer-network/2.png" alt="分组交换"></p><p><em>注：图中的报文交换即为将报文不拆分为较短的、固定长度的数据段的报文交换方式</em></p><h2 id="计算机网络类别"><a href="#计算机网络类别" class="headerlink" title="计算机网络类别"></a>计算机网络类别</h2><ul><li>按照作用范围分<ul><li>广域网(WAN)：广域网的作用范围通常为几十到几千公里，是互联网的核心部分，其任务是通过长距离运送主机发送给的数据，速度高、通信量大</li><li>城域网(MAN)：作用范围通常为一个城市，可以跨越几个街区甚至整个城市。目前城域网很多采用以太网技术，因此有时也常常并入局域网的范围</li><li>局域网(LAN)：一般工作范在1km左右</li><li>个人区域网(PAN)：个人网络，通常只有10m左右</li></ul></li><li>按照使用者分<ul><li>公用网(public network)：指电信公司出资建造的大型网络，这种网络通常是提供给所有愿意缴纳费用的人</li><li>专用网(private network)：某个部门为了满足本单位的需要而建造的网络，这种网络不向本单位以外的人提供服务</li></ul></li><li>用来把用户接入到互联网的网络<ul><li>这种网络称为接入网(AN)，即与宽带接入技术有关的网络</li></ul></li></ul><h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>速率的单位为 <code>bit/s</code>，有时写作<code>bps</code>，含义为：<font color=red>每秒传输的比特位个数</font>。<strong>注意，这与通常提及的网速单位不同，通常网速的单位为 B/s 而不是 b/s</strong></p><script type="math/tex; mode=display">1Gbps = 1000Mbps = 10^6 Kbps = 10^9 bps</script><script type="math/tex; mode=display">1 B/s = 8 bps</script><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>通常带宽指代某个<strong>信号具有的频带宽度</strong>，单位为<code>Hz</code></p><p>在计算机网络中，带宽和速率同义，单位为<code>bit/s</code></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>在单位时间内，通过某个网络的实际数据量</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>指数据从网络的一段传送到另一端所需要的时间</p><ul><li>发送时延：主机或路由器发送数据帧需要的时间。从发送数据帧的第一个比特开始到最后一个比特发送完毕所需要的时间 $发送时延 = \frac{数据帧长度(bit)}{速率(bit/s)}$</li><li>传播时延：电磁波在信道中传播一定的距离需要花费的时间 $传播时延 = \frac{链路长度(m)}{数据在链路上的传播速度(m/s)}$</li><li>处理时延：主机或路由器收到分组后需要花费时间进行处理。包括分析数据首部、提取数据部分、差错检验、寻找下一个路由</li><li>排队时延：分组经过网络传输时，在进入路由器后需要在输入队列中等待处理，待路由器确定了转发接口后，还要在输出队列中等待转发</li></ul><script type="math/tex; mode=display">总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</script><p><strong>提高数据的发送速率只能减小数据的发送时延</strong></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>表示通信管道链路中总共可以容纳多少个比特</p><script type="math/tex; mode=display">时延带宽积 = 传播时延 \times 带宽</script><h3 id="往返时间-RTT"><a href="#往返时间-RTT" class="headerlink" title="往返时间 RTT"></a>往返时间 RTT</h3><script type="math/tex; mode=display">有效数据率 = \frac{数据长度}{发送时间 + RTT}</script><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>利用率有信道利用率和网络利用率两种</p><ul><li>信道利用率：某信道有百分之几的时间是被利用的(有数据通过)。信道利用率并非越高越好，信道利用率越大，则该信道的时延就会增加。令 $D_0$ 表示网络空闲时的时延，$D$ 表示网络当前的时延，信道利用率用$U$表示，则<script type="math/tex; mode=display">D = \frac{D_0}{1-U}</script>通常较大的主干网的 ISP 的信道利用率不超过 50%</li><li>网络利用率：全网络的信道利用率的加权平均值</li></ul><h3 id="其他非性能特征"><a href="#其他非性能特征" class="headerlink" title="其他非性能特征"></a>其他非性能特征</h3><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可拓展性和可升级性</li><li>易于管理和维护</li></ul><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>规定了所交换数据的格式以及有关的同步问题规则称为网络协议，主要由下面三个要素构成</p><ul><li>语法：数据与控制信息的结构或格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：事件实现顺序的详细说明</li></ul><h3 id="网络层次"><a href="#网络层次" class="headerlink" title="网络层次"></a>网络层次</h3><p>分层的好处：</p><ul><li>各层之间是独立的</li><li>灵活性好</li><li>结构上可分割开</li><li>易于实现和维护</li><li>能促进标准化工作<ul><li>差错控制</li><li>流量控制</li><li>分段和重装</li><li>复用和分用</li><li>连接建立和释放</li></ul></li></ul><h3 id="五层协议结构"><a href="#五层协议结构" class="headerlink" title="五层协议结构"></a>五层协议结构</h3><h4 id="应用层-application-layer"><a href="#应用层-application-layer" class="headerlink" title="应用层(application layer)"></a>应用层(application layer)</h4><p>通过应用进程间的交互来完成特定网络应用。对于不同的网络应用需要有不同的应用层协议。例如 DNS(域名系统)，HTTP(万维网应用)，SMTP(电子邮件协议)</p><h4 id="运输层-transport-layer"><a href="#运输层-transport-layer" class="headerlink" title="运输层(transport layer)"></a>运输层(transport layer)</h4><p>负责向两台主机中进程通信提供通用的数据传输服务。主要有两种协议：</p><ul><li>TCP(传输控制协议)：面向连接的、可靠的数据传输服务。其数据传输的单位是<strong>报文段</strong></li><li>UDP(用户数据报协议)：提供无连接的、尽最大努力的数据传输服务，不保证数据传输的可靠性。其数据传输的单位是用户<strong>数据报</strong></li></ul><h4 id="网络层-network-layer"><a href="#网络层-network-layer" class="headerlink" title="网络层(network layer)"></a>网络层(network layer)</h4><p>负责为<a href="#分组交换">分组交换</a>网上的不同主机提供通信服务，将运输层产生的报文段或用户数据封装成分组或包进行传送。IP 协议</p><h4 id="数据链路层-data-link-layer"><a href="#数据链路层-data-link-layer" class="headerlink" title="数据链路层(data link layer)"></a>数据链路层(data link layer)</h4><p>将IP数据报组装成帧(framing)，添加控制信息(同步信息、地址信息、差错控制)。检查所收到的帧中是否有差错。与 mac 地址有关</p><h4 id="物理层-physical-layer"><a href="#物理层-physical-layer" class="headerlink" title="物理层(physical layer)"></a>物理层(physical layer)</h4><p>传输比特流</p><h3 id="实体、协议、服务-和服务访问点："><a href="#实体、协议、服务-和服务访问点：" class="headerlink" title="实体、协议、服务 和服务访问点："></a>实体、协议、服务 和服务访问点：</h3><ul><li>实体(entity)——表示任何可发送或接收信息的硬件或软件进程。</li><li>协议——控制两个对等实体进行通信的规则的集合。</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</li><li>要实现本层协议，还需要使用下层所提供的服务。</li><li>下面的协议对上面的服务用户是透明的。</li><li>协议是“水平的”，即协议是控制对等实体之间通信的规则。</li><li>服务是“垂直的”，即服务是由下层向上层通 过层间接口提供的。</li><li>同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)</li><li>协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的，必须非常仔细地检查这个协议能否应付各种异常情况。</li></ul><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层的主要任务是<font color=red>确定与传输媒体的接口有关的一些特性</font></p><ul><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</li><li>电器特性：指明在接口电缆的各条线上出现的电压的范围</li><li>功能特性：指明某条线上出现的某一电平的电压的意义</li><li>过程特性：指明对于不同功能的各种可能事件出现的顺序</li></ul><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><p>一个数据通信系统可以划分为三大部分</p><ul><li>源系统<ul><li>源点：源点设备产生要传输的数据</li><li>发送器：调制器(调制解调器)</li></ul></li><li>传输系统</li><li>目标系统<ul><li>接收器：解调器(调制解调器)</li><li>终点</li></ul></li></ul><h3 id="通信系统中的术语"><a href="#通信系统中的术语" class="headerlink" title="通信系统中的术语"></a>通信系统中的术语</h3><ul><li>消息(message)：运送消息的实体</li><li>信号(signal)：数据的电气或电磁的表现<ul><li>模拟信号(连续信号)：消息的参数取值是连续的</li><li>数字信号(离散信号)：消息的参数取值是离散的</li></ul></li><li>单向通信(单工通信)：只能有一个方向的通信而没有反方向的交互</li><li>双向交替通信(半双工通信/单工)：双方都可以发送信息，但是双方不能同时发送信息</li><li>双向同时通信(全双工通信)：双方可以同时发送给和接受信息</li><li>基带信号：由源点产生的信号。通常包含有低频甚至直流成分，需要通过调制器进行调制(modulation)</li><li>调制：对基带信号进行的变换<ul><li>基带调制(编码)：仅仅对基带信号的波形进行变换，使它能够与信道特性相适应，变换后仍然是基带信号<ul><li>不归零制：正电平表示1，负电平表示0</li><li>归零制：正脉冲表示1，负脉冲表示0</li><li>曼切斯特编码：周期中心向上跳为0，周期中心向下跳为1</li><li>差分曼切斯特编码：位开始边界有跳位0，没有跳变为1。每个位中间必须进行一次跳变<br><img src="/image/notebook/Computer-network/3.png" alt="编码"></li></ul></li><li>带通调制：使用载波(carrier)进行调制，将基带的信号频率范围搬移到高频率段，并转换为模拟信号(为了达到更高的信息传输速率，通常采用复杂的多元振幅相位混合调制方法QAM)<ul><li>调幅(AM)：载波的振幅随着基带数字信号变化而变化</li><li>调频(FM)：载波的频率随着基带数字信号变化而变化</li><li>调相(PM)：载波的初始相位随基带数字信号变化而变化</li></ul></li></ul></li></ul><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><ul><li>信道能够通过的频率范围：在任何信道中，，码元传输的速率是有上线的，传输速率超过此上线，就会出现严重的码间串扰的问题，使接收端对码元的识别称为不可能</li><li>信噪比：所有电子设备和通信信道中，会随机产生噪音。如果信号相对较强，则噪音的影响就相对较小。<script type="math/tex; mode=display">信噪比(dB) = 10 \times log_{10}(\frac{信号的平均功率(S)}{噪音的平均功率(N)}) (dB)</script></li><li>信道极限信息传输速率$C$为<script type="math/tex; mode=display">C = W \times log_2(1 + \frac{S}{N}) (bit/s)</script>其中，$W$ 为信道的带宽(Hz)，$S$ 为信道内所传信号的平均功率，$N$ 信道内部的(高斯)噪音的功率</li></ul><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><ul><li>导引型传输媒体：<ul><li>双绞线：屏蔽双绞线，无屏蔽双绞线</li><li>同轴电缆</li><li>光缆<ul><li>单模光纤：纤芯细，光线不会经过多次反射，成本高，传输距离远</li><li>多模光纤：可以同时传输多个光路，容易失真，只适合近距离传输</li></ul></li></ul></li><li>非导引型传输媒体<ul><li>短波</li><li>微波</li><li>卫星</li></ul></li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ul><li>频分复用：所有用户在同样的时间占用不同的带宽（频率带宽）资源</li><li>时分复用：将时间划分为一段段等长的时分复用帧(TDM 帧)。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性地出现(其周期就是 TDM 帧的长度)。TDM 信号也称为等时(isochronous)信号。时分复用的所有用户是在不同的时间占用同样的频带宽度。</li><li>统计时分复用(提供时分复用的利用率)</li><li>波分复用：光的频分复用。</li><li>码分复用CDM：常用的名词是码分多址 CDMA。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。每一个比特时间划分为 m 个短的间隔，称为码片(chip)。当码片序列长度为$m$ bit发送的信息的速率为$b$ bit/s，则实际的发送速率要达到$mb$ bit/s。CDMA 的重要特点：每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。</li></ul><h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><p>略</p><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p>略</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>链路层使用的信道分为两种类型：</p><ul><li>点对点信道：一对一</li><li>广播信道：一对多</li></ul><h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><ul><li>链路(link)：是一条无源的点到点（一个节点到相邻节点）的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li><li>数据链路(data link)：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。最常用的就是网络适配器（即网卡）。</li><li>帧：数据链路层的协议数据单元。数据链路层把网络层交下来的数据打包成帧发送到链路上，以及把接收到的帧中的数据取出并交给网络层</li></ul><h3 id="数据链路层协议"><a href="#数据链路层协议" class="headerlink" title="数据链路层协议"></a>数据链路层协议</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul><li>在一段数据的前后分别添加首部和尾部，构成一个帧。</li><li>首部和尾部的一个重要作用就是进行帧定界(确定一个帧的界限)。</li><li>每一种链路层协议都规定了所能传送的帧的数据部分长度的上限——最大传送单元(MTU)</li><li>控制字符SOH(Start Of Header)放在一帧的最前面，EOT(End Of Transmission)放在一帧的结束。如果只有SOH没有EOT则丢弃。(SOH = 0x01，EOT = 0x04)</li></ul><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>由于数据部分也有可能出现 EOT 的字符导致数据链路层会错误的找到帧的边界。若发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”，则在前面插入一个转义字符“ESC”(其十六进制编码是 0x1B)，如果出现了转义字符“ESC”，则再插入一个“ESC”。这种办法称为<strong>字节填充</strong></p><h4 id="差错检验"><a href="#差错检验" class="headerlink" title="差错检验"></a>差错检验</h4><h5 id="CRC-循环冗余检验"><a href="#CRC-循环冗余检验" class="headerlink" title="CRC(循环冗余检验)"></a><font color=red>CRC(循环冗余检验)</font></h5><p>在发送端，先把数据划分为组，每组 $k$ 个比特，将每组的数据用二进制的模2运算进行$2^n$乘的运算，然后在每组数据后添加 $n$ 位冗余码。</p><blockquote><p>假定本组数据为 $M = 101001$，$n = 3$。假定除数$P = 1101(n + 1位)$<br>首先在 $M$ 后添加 $n$ 位 $0$，得到 $2^nM = 101001000$<br>将新得到的值与 $P$ 进行模2除法(进行异或运算，直到最后一位)<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml">        <span class="hljs-number">110101</span> <span class="hljs-string">(商)</span><br>    <span class="hljs-string">+---------</span><br><span class="hljs-number">1101</span><span class="hljs-string">|101001000</span> <span class="hljs-string">(被除数)</span><br>     <span class="hljs-number">1101</span><br>    <span class="hljs-string">----------</span><br>      <span class="hljs-number">1110</span>     <span class="hljs-string">(每次运算使用的是异或运算，而不是减法)</span><br>      <span class="hljs-number">1101</span><br>    <span class="hljs-string">----------</span><br>       <span class="hljs-number">0111</span>    <span class="hljs-string">(每次运算时，如果首位是0，则商为0，如果首位是1，则商为1)</span><br>       <span class="hljs-number">0000</span><br>    <span class="hljs-string">----------</span><br>        <span class="hljs-number">1110</span><br>        <span class="hljs-number">1101</span><br>    <span class="hljs-string">----------</span><br>         <span class="hljs-number">0110</span><br>         <span class="hljs-number">0000</span><br>    <span class="hljs-string">----------</span><br>          <span class="hljs-number">1100</span><br>          <span class="hljs-number">1101</span><br>    <span class="hljs-string">----------</span><br>           <span class="hljs-number">001</span> <span class="hljs-string">(余数R)</span><br></code></pre></td></tr></table></figure><br>将余数$R = 001$添加至 $M$ 后，得到CPC后的结果为 $101001001$</p></blockquote><p>CPC校验只能判断这个帧是否有差错，不能判断哪一位或者哪几位除了差错</p><p>仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。</p><p>“无差错接受”是指:“凡是接受的帧(即不包括丢弃的帧)，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说:“凡是接收端数据链路层接受的帧都没有传输差错”(有差错的帧就丢弃而不接受)。要做到“可靠传输”(即发送什么就收到什么)就必须再加上确认和重传机制</p><p>在数据后面添加上的冗余码称为帧检验序列 FCS</p><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><ul><li>PPP协议的功能<ul><li>简单：这是首要的要求，互操作性提高了</li><li>封装成帧：必须规定特殊字符作为帧定界符</li><li>透明性</li><li>多种网络层协议：同一条物理链路上同时支持多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传输单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul></li><li>PPP协议不需要的功能<ul><li>纠错</li><li>流量控制</li><li>序号</li><li>多点线路</li><li>半双工或单工链路</li></ul></li><li>PPP协议的组成<ul><li>一个将IP数据报封装到串行链路的方法</li><li>链路控制协议 LCP(Link Control Protocol)</li><li>网络控制协议 NCP(Network Control Portocol)</li></ul></li><li>PPP协议的帧格式<ul><li>各字段的含义<ul><li>其中，首部的第一个字段和尾部的最后一个字段 F(flag) 都是 <code>0x7E</code>，表示一个帧的开始或结束。</li><li>首部中的地址字段 A 规定为 <code>0xFF</code>，控制字段 C 规定为 <code>0x03</code> 这两个字段并没有携带 PPP 帧的信息</li><li>首部中第四个字段为协议字段，当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。若为 0xC021, 则信息字段是 PPP 链路控制数据。若为 0x8021，则表示这是网络控制数据。</li><li><font color=red>信息字段的长度是可变的，不超过 1500 字节</font></li><li>尾部中的第一个字段是用于CRC的帧校验序列FCS</li></ul></li><li>字节填充<ul><li>将信息字段中出现的每一个 <code>0x7E</code> 字节转变成为 2 字节序列(<code>0x7D</code>, <code>0x5E</code>)。</li><li>若信息字段中出现一个 <code>0x7D</code> 的字节，则将其转变成为 2 字节序列(<code>0x7D</code>, <code>0x5D</code>)。</li><li>若信息字段中出现 ASCII 码的控制字符 (即数值小于 <code>0x20</code> 的字符)，则在该字 符前面要加入一个 <code>0x7D</code> 字节，同时将该字符的编码加以改变。例如出现 <code>0x03</code>，则要改为 <code>0x7D</code>，<code>0x23</code></li></ul></li><li>零比特填充：PPP 协议用在 SONET/SDH 链路时，是使用同步传输，这时 PPP 协议采用零比特填充方法来实现透明传输。信息字段每出现5个连续的1，则添加一个0，这样不会产生控制字符<code>F</code>相同的信息部分。<br><img src="/image/notebook/Computer-network/4.png" alt="PPP帧"></li></ul></li><li>PPP协议的工作状态：略</li></ul><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><h3 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h3><p>共享信道技术：</p><ul><li>静态划分信道</li><li>动态媒体接入控制<ul><li>随机接入</li><li>受控接入</li></ul></li></ul><h3 id="CSMA-CD-协议-Carrier-Sense-Multiple-Access-with-Collision-Detection-载波侦听多路访问-碰撞检测"><a href="#CSMA-CD-协议-Carrier-Sense-Multiple-Access-with-Collision-Detection-载波侦听多路访问-碰撞检测" class="headerlink" title="CSMA/CD 协议(Carrier Sense Multiple Access with Collision Detection 载波侦听多路访问/碰撞检测)"></a><font color=red>CSMA/CD 协议(Carrier Sense Multiple Access with Collision Detection 载波侦听多路访问/碰撞检测)</font></h3><ul><li>以太网<ul><li>所有计算机连接到一根总线上</li><li>采用无连接的工作方式</li><li>差错帧是否需要重传由高层决定</li><li>使用<a href="#通信系统中的术语">曼切斯特编码</a></li></ul></li><li>CSMA/CD 协议<ul><li>多点接入：许多计算机以多点接入的方式连接在一根总线上</li><li>载波监听：用电子技术监听总线上有没有其他计算机在发送数据</li><li>碰撞检测：边发送边监听</li></ul></li></ul><h4 id="截断二进制指数退避"><a href="#截断二进制指数退避" class="headerlink" title="截断二进制指数退避"></a><font color=red>截断二进制指数退避</font></h4><p>当发送的数据包发生碰撞冲突时，以太网使用截断二进制指数退避法</p><ul><li>确定一个争用期时间：以太网把争用期定为 $51.2 \mu s$。<ul><li>早期的以太网的网速为 $10Mbps$，所以在此时间内，计算机总共能够发送 64 字节的数据(512bit)。所以这个时间通常也被叫做512比特时间</li></ul></li><li>当数据包开始发送的 $51.2 \mu s$ 内，如果接收到了其他计算机发送的数据包，则认为此次数据包发生了碰撞，并立即停止数据包的传输。</li><li>发生冲突的双方从 $[0, (2^k - 1)]$ 范围中随机取出一个整数，记为 $r$<script type="math/tex; mode=display">k = min\{重传次数(第一次为1), 10\}</script></li><li>下一次重传的将在 $r$ 倍的争用期</li><li>当重传达到 $16$ 次仍不能成功时，则放弃，并向高层报告</li></ul><blockquote><p>例如，在第1次重传时，k=1，随机数 $r$ 从整数 <script type="math/tex">\{0,1\}</script> 中选一个数。因此重传推迟的时间是0或争用期，在这两个时间中随机选择一个。整数范围的选择为2的k次方个数<br>若再发生碰撞，则重传时，k=2，随机数 $r$ 就从整数 <script type="math/tex">\{0,1,2,3\}</script> 中选一个数。因此重传推迟的时间是在$0, 1, 2, 3$倍的争用期这4个时间中随机抽取一个<br>同样，若在发生碰撞，则重传时k=3，随机数 $r$ 就从整数 <script type="math/tex">\{0,1,2,3,4,5,6,7\}</script> 中选一个数。以此类推</p></blockquote><p>同时，以太网规定了最短的帧长为 64 字节，如果要发送的数据小于此数值，则必须要填入一些字节使得帧长不小于 64 字节。同样，如果发送方发送的帧数据在争用期(64比特)内没有发送碰撞，则后续发送的数据一定不会发生碰撞</p><p>对于接收方，如果接收到的帧小于 64 字节，则可以认为这是由于冲突而异常中止的无效帧</p><p>同时为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备，以太网还规定了帧间最小间隔 $9.6 \mu s$</p><h4 id="CSMA-CD-协议要点归纳"><a href="#CSMA-CD-协议要点归纳" class="headerlink" title="CSMA/CD 协议要点归纳"></a>CSMA/CD 协议要点归纳</h4><ul><li>准备发送</li><li>检测信道</li><li>在发送过程中仍不停检测信道<ul><li>发送成功：在争用期内没有检测到碰撞</li><li>发送失败：在争用期内检测到碰撞，立即停止发送数据</li></ul></li></ul><p>以太网每发送一帧，一定要把已发送是帧保留一下，如果在争用期内检测到了碰撞，则此帧需要重传</p><h3 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h3><p>略</p><h3 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h3><script type="math/tex; mode=display">S_{max} = \frac{T_0}{T_0 + \tau} = \frac{1}{1+\frac{\tau}{T_0}}</script><script type="math/tex; mode=display">T_0 = \frac{帧长(bit)}{发送速率(bit/s)}</script><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><p>mac地址是计算机中固化在适配器ROM中的地址，简单来说mac地址由电脑硬件直接决定，<font color=red>长度为 48 位(6 个字节)</font>。制作适配器的厂商通常需要向 IEEE 的 RA 购买 OUI(组织唯一标识符，也可以理解为是mac地址段)</p><h3 id="适配器过滤"><a href="#适配器过滤" class="headerlink" title="适配器过滤"></a>适配器过滤</h3><p>适配器在接收到 mac 帧后，先用硬件检查 mac 帧中的目的地址，如果是发往本站的帧则收下，否则丢弃掉。<br>这里“发往本机的帧”包括以下三种：</p><ul><li>单播(unicast)：一对一</li><li>广播(broadcast)：一对全体</li><li>多播(multicast)：一对多</li></ul><p>一些适配器可以设置为混杂模式，工作在混杂方式的适配器会将以太网上传输的所有帧都接受下来。这样实际上是窃听其他站点的通信</p><h3 id="mac帧格式"><a href="#mac帧格式" class="headerlink" title="mac帧格式"></a>mac帧格式</h3><p><img src="/image/notebook/Computer-network/5.png" alt="mac帧格式"></p><ul><li>前两个字段为目的地址和源地址</li><li>第三个字段为类型字段，用来标志上一层使用的是说明协议。例如为 <code>0x0800</code> 时为 IP 数据报，为 <code>0x8137</code> 为 Novell IPX</li><li>第四个字段为数据段，长度在 46 到 1500 字节(46 = 最短长度 64 字节 - 第一个字段 6 字节 - 第二个字段 6 字节 - 第三个字段 2 字节 - 第五个字段 4 字节)</li><li>第五个字段是帧校验序列 CRC</li><li>将 mac 帧向物理层传输时，还需要在开头加上 7 个字节的前同步码，同步码是由 <code>10</code> 串组成，使得接收端的适配器能够根据同步码的频率来调制时钟频率。和一个字节的帧开始界定符</li></ul><h3 id="无效的-mac-帧"><a href="#无效的-mac-帧" class="headerlink" title="无效的 mac 帧"></a>无效的 mac 帧</h3><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列 FCS 由差错</li><li>收到的帧的 mac 数据字段的长度不在 46-1500 字节之间</li></ul><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><p>略</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>虚电路服务：通过网络层来实现可靠的传输网络协议，面向连接，类似打电话时的连接建立过程</li><li>数据报服务：不提供服务质量的保证，不需要建立连接</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方面</th><th style="text-align:center">虚电路服务</th><th style="text-align:center">数据报服务(采用的)</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">可靠的通信应当由网络来保证</td><td style="text-align:center">可靠的通信应当由用户主机来保证</td></tr><tr><td style="text-align:center">连接的建立</td><td style="text-align:center">必须有</td><td style="text-align:center">不需要</td></tr><tr><td style="text-align:center">终点的地址</td><td style="text-align:center">仅在建立连接阶段使用，每个分组使用短的虚电路号</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组转发</td><td style="text-align:center">属于同一条虚电路的分组均按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">当结点出现故障时</td><td style="text-align:center">所有通过出故障的结点的虚电路均不能工作</td><td style="text-align:center">出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按照顺序到达终点</td><td style="text-align:center">到达终点的顺序不一定按照发送顺序</td></tr><tr><td style="text-align:center">端到端的差错处理和流量控制</td><td style="text-align:center">可以由网络负责，也可以由用户主机负责</td><td style="text-align:center">由用户主机负责</td></tr></tbody></table></div><h2 id="网络协议-IP"><a href="#网络协议-IP" class="headerlink" title="网络协议 IP"></a>网络协议 IP</h2><p>与 IP 协议配套使用的还有三个协议</p><ul><li>ARP(地址解析协议)</li><li>ICMP(网络控制报文协议)</li><li>IGMP(网际组管理协议)</li></ul><h3 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h3><p>网络上使用的中间设备</p><ul><li>物理层：转发器</li><li>数据链路层：网桥</li><li>网络层：路由器</li><li>网络层以上：网关</li></ul><h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><p>IP地址有两个固定长度的字段组成，第一个字段为<strong>网络号</strong>，第二个为<strong>主机号</strong>。一个 IP 地址在整个互联网范围内是唯一的，</p><p><img src="/image/notebook/Computer-network/6.png" alt="IP地址分类"></p><ul><li>A类、B类、C类地址的网络号字段分别为1个、2个和3个字节长，而在网络号字段的最前面有 1-3 位的类别位，其数值分别规定位 <code>0</code>、<code>10</code>、<code>110</code></li><li>A类、B类、C类地址的主机号的主机号字段分别为3个、2个、1个字节长</li><li>A类、B类、C类的地址都是单播<a href="#适配器过滤">见适配器过滤</a>地址</li><li>D类地址(前4位是<code>1110</code>)用于多播</li><li>E类地址(前4位是<code>1111</code>)保留为以后用</li></ul><p>IP 地址的指派范围</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络类别</th><th style="text-align:center">最大可以指派的网络数</th><th style="text-align:center">第一个可以指派的网络号</th><th style="text-align:center">最后可以指派的网络号</th><th style="text-align:center">每个网络中的最大主机数</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">126($2^{7} - 2$)</td><td style="text-align:center">1</td><td style="text-align:center">126</td><td style="text-align:center">16777214($2^{24} - 2$)</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">16383($2^{14} - 1$)</td><td style="text-align:center">128.1</td><td style="text-align:center">191.255</td><td style="text-align:center">65534($2^{14} - 1$)</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">2097151($2^{21} - 1$)</td><td style="text-align:center">192.0.1</td><td style="text-align:center">223.255.255</td><td style="text-align:center">254</td></tr></tbody></table></div><p>特殊的 IP 地址</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">主机号</th><th style="text-align:center">源地址使用</th><th style="text-align:center">目的地址使用</th><th style="text-align:center">代表的含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">可以</td><td style="text-align:center">不可以</td><td style="text-align:center">本网络上的本主机</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">非全0且非全1</td><td style="text-align:center">可以</td><td style="text-align:center">不可以</td><td style="text-align:center">在本网络上的某台主机</td></tr><tr><td style="text-align:center">全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可以</td><td style="text-align:center">可以</td><td style="text-align:center">在本网络上进行广播</td></tr><tr><td style="text-align:center">非全0且非全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可以</td><td style="text-align:center">可以</td><td style="text-align:center">对某个网络上的所有主机进行广播</td></tr><tr><td style="text-align:center">127</td><td style="text-align:center">非全0且非全1</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td><td style="text-align:center">本机</td></tr></tbody></table></div><p>IP 地址的一些特点</p><ul><li>每一个 IP 地址都由网络号和主机号两部分组成</li><li>实际上 IP 地址标志的是一台主机(或路由器)和一条链路的接口</li><li>一个网络指的是具有相同网络号的主机的集合</li><li>在 IP 地址中，所有分配到网络号的网络都是平等的</li><li>同一个局域网上的主机或者路由器的 IP 地址中的网络号必须是一样的</li><li>用网桥(它工作在链路层)互连的网段仍然是一个局域网，网络号必须相同</li><li>路由器总是拥有两个或更多的 IP 地址，即路由器的每一个接口都有一个不同网络号的 IP 地址</li><li>当两个路由器相连时，在接口两端处，可以分配也可以不分配 IP</li></ul><h3 id="IP-地址与硬件地址-mac地址"><a href="#IP-地址与硬件地址-mac地址" class="headerlink" title="IP 地址与硬件地址(mac地址)"></a>IP 地址与硬件地址(mac地址)</h3><ul><li>物理地址/硬件地址/mac 地址是数据链路层和物理层使用的地址，是固定的</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</li><li>在 IP 层抽象的互联网上只能看到 IP 数据报。IP 数据报不论转发多少次，其数据报中的 IP 地址始终是源地址和目的地址。</li><li>虽然 IP 数据报首部有源 IP 地址，但是路由器只根据目的站的 IP 地址进行转发</li><li>在链路层，只能看到 mac 帧，IP。数据报倍封装在 mac 帧中，mac 地址在不同网络中时，mac 帧内的源地址和目标地址会发生变化，具体表现为，对于每一次转发，其 mac 帧内的源地址和目标地址都会发生变化</li><li>考虑网络层时，可以是哟个统一的、抽象的 IP 地址来研究主机和主机或者路由器之间的通信</li></ul><h3 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP(地址解析协议)"></a>ARP(地址解析协议)</h3><p>将网络层得到的 IP 地址转为下一跳的 mac 地址的过程(将 IP 地址映射到 mac 地址)</p><ul><li>当主机 A 需要向 主机 B 发送 IP 数据报时，首先根据主机 B 的 IP 的地址，在本机的 ARP 缓存中寻找是否有主机 B 的 IP 地址，如果有，则可以获取主机 B 的 mac 地址</li><li>如果没有主机 B 的 IP，则向本局域网上广播一个 ARP 请求</li><li>在本局域网上的所有主机运行的 ARP 进程都收到此 ARP 请求</li><li>ARP 进程查询本机的 IP 是否与请求的 IP 相同，如果相同，则向主机 A 发送 ARP 响应</li><li>主机 A 收到主机 B 的 ARP 响应后，将此 mac 地址和 IP 写入 ARP 缓存</li></ul><p>为什么<font color=red><strong>不直接使用 mac 地址进行通信</strong></font></p><p>全世界存在各种各样的异构网络，它们使用不同的硬件地址(网络的异构性体现），要使这些异构网络能够进行通信，就需要非常复杂的硬件地址转换工作，因此由用户主机来完成这件事几乎是不可能的，使用统一的IP地址，就使得所有的主机都在同一个IP网络内进行通信。</p><p>mac地址不具备归属地特征，不能作为地址</p><p>为什么<font color=red><strong>不直接使用 IP 地址进行通信</strong></font></p><ol><li>因为并非每个主机都一个公网IP,很多主机都是使用的内网IP，依据NAT对外访问</li><li>IP地址是动态变化的</li></ol><h3 id="IP-数据报的格式"><a href="#IP-数据报的格式" class="headerlink" title="IP 数据报的格式"></a>IP 数据报的格式</h3><p><img src="/image/notebook/Computer-network/7.png" alt="IP 数据报格式"></p><ul><li>版本：占 4 位，指 IP 协议的版本。目前广泛使用的协议为 4 (即 IPv4)</li><li>首部长度：占 4 位，可表示最大十进制数值是 15，单位是 4 字节(32位)。首部长度必须是 4 字节的倍数。由于首部至少为 20 字节，所以首部长度至少为 5</li><li>区分服务：占 8 位，用来获得更好的服务。一般情况下不使用这个字段</li><li>总长度：占 16 位，指首部和数据之和的长度，单位是字节。所以数据报的最长长度位 65535 字节。通常是极少遇到的</li><li>标识：占 16 位，一个存在于 IP 软件中的计数器，每产生一个数据报，计数器就加一，并把此值赋给标识字段。当数据报因为过长而分片时，多个分片的标识符相同，便于接收方进行组装</li><li>标志：占 3 位，但是目前只有两位有意义<ul><li>MF(More Fragment)，最低位：MF = 1表示后面还有分片</li><li>DF(Don`t Fragment)，中间位：DF = 1表示不能分片</li></ul></li><li>片偏移：占13位，较长的数据报分片后，此片在原分组中的相对位置(不是序号)，以 8 个字节位单位。每个分片的长度也一定是 8 个字节的整数倍<blockquote><p>例如，一个数据报长度为 3820 字节，数据部分为 3800 字节，20字节的首部。分为 1400、1400、1000 四个片段，则每个片段的首部的偏移分别为 0、175($1400/8$)、350($2800/8$)</p></blockquote></li><li>生存时间(TTL)：占 8 位，当此数据报经过一次路由器时，TTL 会被减去1，当 TTL 等于 0 时，此数据报就会被丢弃</li><li>协议：表示数据报的协议类型。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">常见的协议</th><th style="text-align:center">ICMP</th><th style="text-align:center">IGMP</th><th style="text-align:center">IP(一种特殊的数据报)</th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th><th style="text-align:center">IPv6</th></tr></thead><tbody><tr><td style="text-align:center">协议字段值</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">17</td><td style="text-align:center">41</td></tr></tbody></table></div><ul><li>首部检验和：占 16 位。仅检验数据报首部的数据是否正确</li><li>源地址：占 32 位</li><li>目的地址：占 32 位</li><li>可变字段：很少被用到</li></ul><h3 id="IP-层的转发分组的流程"><a href="#IP-层的转发分组的流程" class="headerlink" title="IP 层的转发分组的流程"></a>IP 层的转发分组的流程</h3><ul><li>从数据报的首部提取目标主机的 IP 地址 D，得出目的网络地址位 N</li><li>若 N 就是与此路由器直接相连的某个网络地址，则直接交付</li><li>若路由表中有目的地址位 D 的特定主机路由，则将数据报交给下一跳的路由器</li><li>若路由表中有到达网络 N 的路由，则将数据报交给下一跳的路由器</li><li>若路由表中有默认的路由，则将数据报交给默认路由</li><li>报告分组出错</li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>由于两级 IP 地址不够灵活，于是 IP 地址从原来的两级结构改为了通过子网掩码划分网络的 CIDR (无分类域间路由选择)模式，即 IP + 子网掩码的方式，不再有 A类、B类、C类的划分</p><p>即</p><script type="math/tex; mode=display">IP = 网络前缀 + 主机号</script><script type="math/tex; mode=display">网络前缀 = IP \space \& 子网掩码</script><p>通常可以使用“斜线记法”来表示 IP，即在 IP 地址后加上斜线，并写上网络前缀所占的位数</p><blockquote><p>例如 IP = 128.14.35.7/20 表示 128.14.35.7 的前 20 位作为网络前缀，剩下的作为主机号。即网络前缀为：128.14.32.0</p></blockquote><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>由于使用了变长的子网掩码，导致路由表中会出现多个匹配的结果，此时应当选择匹配结果中具有最长网络前缀的路由</p><h3 id="子网的划分方法"><a href="#子网的划分方法" class="headerlink" title="子网的划分方法"></a>子网的划分方法</h3><ul><li>将需要的划分网络出的网络分割为最小的单元</li><li>不断合并最小单元，直到满足最大的网络</li><li>重复上述操作，直到所有网络都满足</li></ul><blockquote><p>例如，一个自治系统内有 5 个局域网，该自治系统分配到的 IP 地址块为 <code>218.75.230.0/24</code> 将此网络划分为 5 个子网，每个子网的设备数如下：9、28、15、13、4<br>首先将所有的子网的设备数加2后，向上取整至2的幂次倍数，然后再将所有值分割为最小值的 $k$ 次倍，假定最小值为 $2^n$，这里取 $n = 3$</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">设备数</th><th style="text-align:center">加2后</th><th style="text-align:center">取整后</th><th style="text-align:center">分割后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">9</td><td style="text-align:center">11</td><td style="text-align:center">16</td><td style="text-align:center">2个8</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">28</td><td style="text-align:center">30</td><td style="text-align:center">32</td><td style="text-align:center">4个8</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">15</td><td style="text-align:center">17</td><td style="text-align:center">32</td><td style="text-align:center">4个8</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">13</td><td style="text-align:center">15</td><td style="text-align:center">16</td><td style="text-align:center">2个8</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">1个8</td></tr></tbody></table></div><blockquote><p>总计需要 13 个 长度为 8 的子网<br>由于 IP 地址块为 <code>218.75.230.0/24</code>，即可以分配的位数为 $t = 32 - 24 = 8$ 位的字符，相当于可以划分出 $2^{t - n} = 32$ 个子网，每个子网可以容纳 $6$ 台设备，此时掩码为 <code>255.255.255.248</code> <script type="math/tex">248 = \begin{matrix}\underbrace{11111} \\ t个1 \end{matrix} \space \begin{matrix}\underbrace{000} \\ n个0 \end{matrix} = 11111000 = 248</script><br>可以分割整个 IP 地址块得到</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">网络号</th><th style="text-align:center">掩码</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">218.75.230.0</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">218.75.230.8</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">218.75.230.16</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">218.75.230.24</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">218.75.230.32</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">218.75.230.40</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">218.75.230.48</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">218.75.230.56</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">218.75.230.64</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">218.75.230.72</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">218.75.230.80</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">218.75.230.88</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">218.75.230.96</td><td style="text-align:center">255.255.255.248</td></tr></tbody></table></div><blockquote><p>由于只需要 13 个子网，这里只罗列出前 13 个，实际上可以罗列出 32 个<br>按照设备数排序后划分子网得到（注意，合并后，掩码也要合并）</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">设备数</th><th style="text-align:center">加2后</th><th style="text-align:center">取整后</th><th style="text-align:center">分割后</th><th style="text-align:center">子网号</th><th style="text-align:center">子网掩码</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">28</td><td style="text-align:center">30</td><td style="text-align:center">32</td><td style="text-align:center">4个8</td><td style="text-align:center">218.75.230.0</td><td style="text-align:center">255.255.255.224</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">15</td><td style="text-align:center">17</td><td style="text-align:center">32</td><td style="text-align:center">4个8</td><td style="text-align:center">218.75.230.32</td><td style="text-align:center">255.255.255.224</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">13</td><td style="text-align:center">15</td><td style="text-align:center">16</td><td style="text-align:center">2个8</td><td style="text-align:center">218.75.230.64</td><td style="text-align:center">255.255.255.240</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">9</td><td style="text-align:center">11</td><td style="text-align:center">16</td><td style="text-align:center">2个8</td><td style="text-align:center">218.75.230.80</td><td style="text-align:center">255.255.255.240</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">1个8</td><td style="text-align:center">218.75.230.96</td><td style="text-align:center">255.255.255.248</td></tr></tbody></table></div><h2 id="ICMP-网际控制报文协议-互联网控制消息协议"><a href="#ICMP-网际控制报文协议-互联网控制消息协议" class="headerlink" title="ICMP(网际控制报文协议/互联网控制消息协议)"></a>ICMP(网际控制报文协议/互联网控制消息协议)</h2><p>它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决</p><p><img src="/image/notebook/Computer-network/8.png" alt="ICMP报文格式"></p><p>ICMP报文类型</p><div class="table-container"><table><thead><tr><th style="text-align:center">报文类型</th><th style="text-align:center">类型值</th><th style="text-align:center">种类</th></tr></thead><tbody><tr><td style="text-align:center">终点不可达</td><td style="text-align:center">3</td><td style="text-align:center">差错报告报文</td></tr><tr><td style="text-align:center">时间超过</td><td style="text-align:center">11</td><td style="text-align:center">差错报告报文</td></tr><tr><td style="text-align:center">参数问题</td><td style="text-align:center">12</td><td style="text-align:center">差错报告报文</td></tr><tr><td style="text-align:center">改变路由</td><td style="text-align:center">5</td><td style="text-align:center">差错报告报文</td></tr><tr><td style="text-align:center">回送请求和回答</td><td style="text-align:center">8或0</td><td style="text-align:center">询问报文</td></tr><tr><td style="text-align:center">时间戳请求和回答</td><td style="text-align:center">13或14</td><td style="text-align:center">询问报文</td></tr></tbody></table></div><p>不应发送 ICMP 差错报文的类型</p><ul><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文</li><li>对非第一个分片的数据报片，不发送 ICMP 差错报告报文</li><li>对具有多播地址的数据报，不发送 ICMP 差错报告报文</li><li>对具有特殊地址的数据报(127.0.0.0或0.0.0.0)，不发送 ICMP 差错报告报文</li></ul><h3 id="ICMP-的应用"><a href="#ICMP-的应用" class="headerlink" title="ICMP 的应用"></a>ICMP 的应用</h3><ul><li>PING：ping 使用了 ICMP 回送请求与回送回答报文，ping 没有通过 TCP 或者 UDP</li><li>traceroute：路由跟踪，利用了 ICMP 时间超过，通过设置 TTL 来发送一系列报文，获取源主机和目标主机之间的路由线路</li></ul><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><p>路由表中的路由是如何动态更新获取的</p><h3 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h3><ul><li>算法必须是正确的完整的</li><li>算法在计算上应简单</li><li>算法应能适应通信量和网络拓扑的变化</li><li>算法应具有稳定性</li><li>算法应是公平的</li><li>算法应是最佳的</li></ul><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><ul><li>内部网关协议IGP：在一个小的网络系统(AS)内的路由协议，常见的有 RIP和OSPF协议</li><li>外部网关协议EGP：不同网络系统内的路由协议，目前使用的最多的是 BGP 的版本4(BGP-4)</li></ul><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>一个基于距离向量的路由选择协议</p><p>距离指的是跳数，每经过一次路由器则跳数加一，相邻的路由器的跳数为1，跳数最多为 15，超过 15 表示不可达。</p><p>RIP 协议会按照固定的时间间隔和相邻的路由器交换自己的路由表，经过若干次交换后，所有路由器都会得到当前网络中任意一个网络的最优的下一跳路由器地址</p><p>算法逻辑：</p><ul><li>对于来自地址为 X 的相邻路由器发送来的 RIP 报文，先将报文中的所有项目中的下一跳地址都改为 X，然后将所有的距离字段都加一</li><li>对于新的报文中的每一项，假定其目的网络为 N，距离为 d<ul><li>如果自己的路由表中没有目标网络为 N 的，则直接加入到自己的路由表中（从没有数据到有数据）</li><li>如果有目标网络为 N 的，且下一跳地址为 X 的，则直接替换此项（更新原来旧的数据）</li><li>如果有目标网络为 N 的，且下一跳地址不为 X 的，则用 d 与其进行比较，选择距离小的写入路由表（选择最优的）</li></ul></li><li>若一段时间内(3分钟)没有收到相邻的路由器的 RIP 包，则视为此路由器不可达，把其距离设定为 16</li></ul><p><img src="/image/notebook/Computer-network/9.png" alt="RIP报文格式"></p><p>RIP的报文由首部和路由部分组成</p><ul><li>首部：占 4 个字节，其中的命令字段指出报文的意义，1 表示请求路由信息，2 对请求的路由信息的响应或未被请求而发出的路由更新报文。首部后面的全 0 用于凑足 4 个字节，对齐</li><li>路由部分：路由部分由若干个路由信息组成，每个路由信息需要 20 个字节，最多一次可以传输 25 个路由信息<ul><li>协议标记(地址族标识符、地址类别)表示所使用的地址协议，如果采用 IP 地址则此字段为 2</li><li>路由标记填入自治系统号 ASN(此字段考虑的是如果非 RIP 路由器发送的信息时，可以进行区别)</li><li>网络地址</li><li>子网掩码</li><li>下一跳的路由器地址</li><li>度量值：到此网络的距离</li></ul></li></ul><p>RIP 协议的优点：实现简单，开销小，使用 UDP<br>RIP 协议的问题：但是 RIP 能使用的最大距离为 15，限制了网络的规模。当网络出现故障时，要经过比较长的时间才能将此信息传递到所有的路由器(好消息传播得快，坏消息传播的慢)</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>开放最短路径优先协议</p><p>使用分布式的链路状态协议，所有路由器都拥有整个网络的拓扑结构图</p><ul><li>使用洪泛法向本网络中的所有路由器发送信息</li><li>发送的信息是本路由器相邻的所有路由器的链路状态，以及该链路的度量（费用、距离、时延、带宽等）</li><li>只有链路状态发生变化时，路由器才向所有路由器发送此信息</li></ul><p>特点</p><ul><li>所有路由器最终都能获得本网络中的整个路由器拓扑图</li><li>链路状态路由器更新速度快，收敛快</li></ul><p>有时为了能够解决大型网络拓扑图太大的问题，OSPF 可以将网络划分为多个不同的区域，每个路由器仅知道本区域内的拓扑情况，区域之间通过区域边界路由器进行交互</p><p>OSPF 不使用 UDP 而是直接用 IP 数据报传送，减少信息的通信量</p><p><img src="/image/notebook/Computer-network/10.png" alt="OSPF报文结构"></p><ul><li>版本：当前的版本号为 2</li><li>类型<ul><li>问候(Hello)：用来发现和维持邻站的可达性，每隔 10 秒钟交换一次，如果 40 秒内没有发生交换，则认为此路由器不可达，更新数据库并且向其他路由器进行报告</li><li>数据库描述(Database Description)：向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>链路状态请求(Link State Request)：向对方请求发送某些链路状态项目的详细信息</li><li>链路状态更新(Link State Update)：用洪泛法对全网更新</li><li>链路状态确认(Link State Acknowledgment)：对链路更新的确认</li></ul></li><li>分组长度：包括 OSPF 首部在内的分组长度，以字节为单位</li><li>路由器标识符：标志发送该分组的路由器的接口的 IP 地址</li><li>区域标识符：分组属于的区域的标识符</li><li>检验和：用来检测分组中的出错</li><li>鉴别类型：目前只有两种，0 和 1</li><li>鉴别：鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字节的口令</li></ul><p>OSPF的特点</p><ul><li>允许管理员给每条线路指派不同的代价，使得 OSPF 相对灵活</li><li>如果到达同一个网络有多条相同代价的路径，那么可以将通信量分配给这几条路径，使得负载平衡</li><li>所有在 OSPF 路由器之间交换的分组都具有鉴别的功能，保证了仅在可信赖的路由器之间交换链路状态信息</li><li>OSPF 支持可变长度的子网划分和无分类的编址 <a href="#划分子网">CIDR</a></li><li>由于网络中的链路状态经常发生变化，所以链路状态会带上一个 32 位的序号，序号越大状态越新</li></ul><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>边界网关协议(BGP)采用路径向量(path vector)路由选择协议。协议交换路由信息节点数量级是自治系统个数的数量级。刚开始运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在发生变化时更新有变化的部分。</p><p><img src="/image/notebook/Computer-network/11.png" alt="ISP"></p><ul><li>标记：16字节长，用来鉴别收到的 BGP 报文。若不适用鉴别时，应当全为 1</li><li>长度：包括通用首部在内的整个 BGP 报文的长度，以字节为单位</li><li>类型<ul><li>OPEN：打开，用来和另一个 BGP 路由器建立关系</li><li>UPDATE：更新，用来通知某一路由的信息，以及列出要撤销的多条路由</li><li>KEEPALIVE：保活，用来周期性验证邻站的连通性</li><li>NOTIFICATION：通知，用来发送检测到的错误</li></ul></li><li>报文：<ul><li>OPEN<ul><li>版本：1字节，现在为 4</li><li>本自治系统号：2字节，全球唯一</li><li>保持时间：2字节</li><li>BGP 标识符：4个字节，通常为此路由器的 IP 地址</li><li>可选参数长度：1字节</li><li>可选参数</li></ul></li><li>UPDATE<ul><li>不可行路由长度：2字节</li><li>撤销的路由</li><li>路径属性总长度：2字节</li><li>路径属性</li><li>网络层可达性信息(NLRI)</li></ul></li><li>KEEPALIVE：无报文部分</li><li>NOTIFICATION<ul><li>差错代码：1字节</li><li>差错子代码：1字节</li><li>差错数据</li></ul></li></ul></li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由选择和分组转发</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><font color=red>IPv6 的长度为 128 位，而 IPv4 仅 32 位</font><p>IPv4至IPv6的变化：</p><ul><li>更大的地址空间</li><li>扩展的地址层次结构</li><li>灵活的首部格式</li><li>改进的选项</li><li>允许的协议继续扩充</li><li>支持即插即用，不需要 DHCP 进行 IP 分配</li><li>支持资源的预分配</li><li>IPv6 首部改为 8 字节对齐</li></ul><h2 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h2><p>实现一对多通信，主机只需要发送一个数据报，路由器负责复制数据报</p><ul><li>在目的地址中使用多播的标识符(D类地址)，来标识一个多播组</li><li>尽最大努力交付，不保证一定能交付</li><li>首部中的协议字段值为 2，表示使用 IGMP(网际组管理协议)</li><li>不产生 ICMP 差错报文</li><li>无法 Ping 通</li></ul><h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>略</p><h2 id="虚拟专用网络-VPN-和网络地址转换-NAT"><a href="#虚拟专用网络-VPN-和网络地址转换-NAT" class="headerlink" title="虚拟专用网络(VPN)和网络地址转换(NAT)"></a>虚拟专用网络(VPN)和网络地址转换(NAT)</h2><p>IP 地址中有一部分被指定为专有地址。当使用的是专有地址时，说明此地址并非是互联网上的地址，而是本地局域网(专用网)内的地址</p><ul><li><code>10.0.0.0</code> 至 <code>10.255.255.255</code></li><li><code>172.16.0.0</code> 至 <code>172.31.255.255</code></li><li><code>192.168.0.0</code> 至 <code>192.168.255.255</code></li></ul><h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>由于这些地址是专有地址，无法直接在互联网上访问到，所以可以使用 VPN 技术来实现内网的访问。VPN的数据在互联网段是加密数据，所以效果上和真正的专用网一样。</p><ul><li>内联网：两个地区的专用网进行连接</li><li>远程接入VPN：在互联网上的主机访问在专用网内的主机</li></ul><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>每个专用网拥有至少一个互联网的 IP 地址，当专用网内的主机需要和互联网通信时，通过此专用网的 IP 地址和不同端口来临时当作主机的 IP，实现对互联网的访问</p><h2 id="多协议标志交换-MPLS"><a href="#多协议标志交换-MPLS" class="headerlink" title="多协议标志交换(MPLS)"></a>多协议标志交换(MPLS)</h2><p>略</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="运输层的协议概述"><a href="#运输层的协议概述" class="headerlink" title="运输层的协议概述"></a>运输层的协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><p>运输层使得两台主机之间的交互细化到应用程序的进程</p><p>运输层的一个很重要的功能：复用和分用</p><ul><li>复用：发送方不同的应用进程都可以使用同一个运输层协议传输数据</li><li>分用：接收方的运输层在剥去报文的首部后，能够把这些数据正确交付目的应用程序</li></ul><h3 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h3><ul><li>UDP(用户数据报协议)：不需要连接，不提供可靠交互。但在某些情况下却是一种最有效的工作方式</li><li>TCP(传输控制协议)：在传输数据之前必须先建立连接，数据传送结束后，要释放连接，不提供广播或多播服务。提供可靠的、面向连接的运输服务，增加了许多开销</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">应用层协议</th><th style="text-align:center">运输层协议</th></tr></thead><tbody><tr><td style="text-align:center">名字转换</td><td style="text-align:center">DNS(域名服务器)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">文件传送</td><td style="text-align:center">TFTP(简单文件传送协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">路由选择协议</td><td style="text-align:center">RIP(路由信息协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">IP 地址配置</td><td style="text-align:center">DHCP(动态主机配置协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">网络管理</td><td style="text-align:center">SNMP(简单网络管理协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">远程文件服务器</td><td style="text-align:center">NFS(网络文件系统)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">IP 电话</td><td style="text-align:center">专用协议</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">流式多媒体通话</td><td style="text-align:center">专用协议</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">多播</td><td style="text-align:center">IGMP(网际组管理协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">电子邮件</td><td style="text-align:center">SMTP(简单邮件传送协议)</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">远程终端接入</td><td style="text-align:center">TELNET(远程终端协议)</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">万维网</td><td style="text-align:center">HTTP(超文本传送协议)</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">文件传送</td><td style="text-align:center">FTP(文件传送协议)</td><td style="text-align:center">TCP</td></tr></tbody></table></div><h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><p>将不同的应用程序绑定至不同的端口，通过端口来区别不同的应用程序。系统同时拥有 65535 个不同的端口</p><ul><li>服务器端使用的端口号<ul><li>熟知端口号：数值范围为 0-1023 的端口</li><li>登记端口号：数值范围在 1024-49151 的端口</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">应用程序</th><th style="text-align:center">端口号</th></tr></thead><tbody><tr><td style="text-align:center">FTP</td><td style="text-align:center">21</td></tr><tr><td style="text-align:center">TELNET</td><td style="text-align:center">23</td></tr><tr><td style="text-align:center">SMTP</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">DNS</td><td style="text-align:center">53</td></tr><tr><td style="text-align:center">TFTP</td><td style="text-align:center">69</td></tr><tr><td style="text-align:center">HTTP</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">SNMP</td><td style="text-align:center">161</td></tr><tr><td style="text-align:center">SNMP(trap)</td><td style="text-align:center">162</td></tr><tr><td style="text-align:center">HTTPS</td><td style="text-align:center">443</td></tr></tbody></table></div><ul><li>客户端使用的端口号：数值范围为 49152-65535 临时的端口号</li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h3><ul><li>UDP 是无连接的</li><li>UDP 尽最大的努力交付</li><li>UDP 是面向报文的</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一、多对多的交互通信</li><li>UDP 的首部开销小</li></ul><h3 id="UDP-的首部格式"><a href="#UDP-的首部格式" class="headerlink" title="UDP 的首部格式"></a>UDP 的首部格式</h3><p><img src="/image/notebook/Computer-network/12.png" alt="UDP首部格式"></p><ul><li>源端口：源端口号。需要对方回信时使用，不需要时可全为 0</li><li>目的端口：目的端口号。这在终点交付报文时必须使用</li><li>长度：UDP 用户数据报的长度，其最小值为 8（仅有首部）</li><li>检验和：检验 UDP 用户数据报在传输中是否有错</li></ul><h2 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP(传输控制协议)"></a>TCP(传输控制协议)</h2><h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><ul><li>面向连接的运输层协议</li><li>每条 TCP 只能连接两个端点，即{(IP1, 端口1), (IP2，端口2)}</li><li>提供可靠交付的服务</li><li>提供全双工通信</li><li>面向字节流</li></ul><h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><ul><li>超时重传：当发送端发送的数据后，需要等待接收端发送确认收到报告，如果在一段时间内没有收到确认收到报告，则重新发送数据</li><li>暂存已发送的副本：发送端发送了一个分组后，需要暂时保留已发送的分组的副本，同时对所有分组和确认分组进行编号，只有在收到了对应的编号的确认，才可以删除此副本</li><li>确认迟到：当收到重复的分组时，需要丢弃，但仍然需要向发送端发送确认收到</li><li>滑动窗口协议：可以连续发送多个分组，每收到一个请求就可以将滑动窗口向前滑动。而接收方采用累积确认，对按序到达的最后一个分组进行确认，不再对所有有分组进行确认</li></ul><p>以上的逻辑称为自动重传请求(ARQ)</p><h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><p><img src="/image/notebook/Computer-network/13.png" alt="TCP首部格式"></p><p><em>TCP报文段首部的前20个字节是固定的</em></p><ul><li>源端口和目的端口：各占2个字节，表示源端口号和目的端口号，与 UDP 相似</li><li>序号：占4个字节，表示当前数据部分中，第一个字节在整个数据流中的位置</li><li>确认号：占4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则序号 N - 1 为止的所有数据都已经收到了</li><li>数据偏移：占4位，表示TCP首部的长度，单位为 32 位(4字节)，最大值为 15，所以TCP首部最大为 60 字节</li><li>保留：占6位，保留为今后使用，但目前为0</li><li>Flag标记：占6位<ul><li>URG(紧急)：表示此数据应当紧急发送</li><li>ACK(确认)：在建立连接后的所有报文段都必须把 ACK 置为 1</li><li>PSH(推送)：很少使用，希望对方的应用程序尽快处理</li><li>RST(复位)：释放连接，拒绝打开连接</li><li>SYN(同步)：和 ACK 一起配合来实现连接的建立和释放</li><li>FIN(终止)：释放连接</li></ul></li><li>窗口：占2个字节，表示发送本报文的主机的接受数据缓存空间，指明了现在允许对方发送的数据量</li><li>检验和：占2个字节，检验和字段检验的范围包括首部和数据</li><li>紧急指针：占2个字节，仅 URG 为 1 时有意义，指出本报文段中紧急的数据字节数</li><li>选项：长度可变，最长为 40 字节，且必须是 4 字节的整数倍<ul><li>MSS：数据字段长度，默认为 536 字节</li></ul></li></ul><h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p><img src="/image/notebook/Computer-network/14.png" alt="TCP窗口"></p><p>TCP 的滑动窗口是以字节为单位的，滑动窗口内的所有数据包会一次性发送出去，窗口内的数据表示已经发送但是未被确认。假定主机 A 收到的来自主机 B 的确认包的 ACK 为 36，那么滑动窗口将会前移至 36</p><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>基于 <a href="#往返时间-RTT">RTT</a>，定义一个值 <script type="math/tex">RTT_S</script>，此值基于新的 RTT 不断更新，更新公式如下：</p><script type="math/tex; mode=display">RTT_S = (1 - \alpha) \times (RTT_S) + \alpha \times RTT</script><p>通常 $\alpha = 0.125$</p><p>所以定义超时重传时间</p><script type="math/tex; mode=display">RTO = RTT_S + 4 \times RTT_D</script><p>其中 $RTT_D$ 为 $RTT$ 的偏差的加权平均值，其公式如下</p><script type="math/tex; mode=display">\begin{cases}RTT_D = RTT / 2，第一次 \\RTT_D = (1 - \beta) \times RTT_D + \beta \times |RTT_S - RTT|, 后续的情况\end{cases}</script><p>通常 $\beta = 0.25$</p><h3 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h3><p>略</p><h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>TCP 流量控制让发送方发送速率不要太快，要让接收方有足够的缓存来接受数据</p><p><img src="/image/notebook/Computer-network/15.png" alt="TCP流量控制"></p><p>如图中所示，通过 TCP 数据结构中的窗口，实现双方的流量的控制。接收方(R)在发送确认包的同时，将当前的缓存空间发送给发送方(T)，使得双方能够控制传输的速度。而当程序将收到的数据读出后，再将新的空间剩余发送给发送方</p><p>TCP 零窗口死锁：当图片中第五个数据包因为意外丢失时，发送方(T) 一直在等待接收方(R) 发送的新的窗口信息，而接收方(R)也一直在等待发送方(T)发送新的数据，导致了死锁<br>解决办法：为每个连接设有一个持续计时器。当连接的一方收到对方的零窗口通知时，就启动计时器，在计时器到达一定的时间内，就发送一个零窗口探测报文段，而对方如果再次回复零窗口，则重置计时器，如果回复的不是零窗口，则死锁解开</p><h3 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h3><p>略</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使得网络中的路由器或链路不致过载。</p><p>主要是两类控制：</p><ul><li>开环控制：在设计网络时就将有关拥塞的因素考虑周全，力求网络在工作时不会产生拥塞</li><li>闭环控制<ul><li>基于反馈环路，监测网络系统以便在检测到拥塞在何时何处发生</li><li>把拥塞的信息传送到可采取行动的地方</li><li>调整网络的运行以解决出现的问题</li></ul></li></ul><h3 id="实现拥塞控制的四个方法"><a href="#实现拥塞控制的四个方法" class="headerlink" title="实现拥塞控制的四个方法"></a>实现拥塞控制的四个方法</h3><h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><ul><li>发送方设定一个发送窗口(cwnd)，即每次发送的数据不能大于发送窗口的数据(可以认为是 TCP 的滑动窗口)</li><li>开始时，发送窗口的大小设定为一个很小的值</li><li>每当发送方收到一个来自接收方的确认包时，就增大此窗口的大小</li><li>每当出现拥塞(超时)时，就将此窗口再次调整为很小的初始值</li></ul><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>设定一个窗口的极大值(ssthresh)，当窗口的大小超过此极大值时，无论接受到多少个确认包，每次缓慢的增加窗口大小</li><li>出现拥塞时，将此极大值设置为当前窗口的一半</li></ul><h4 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h4><ul><li>要求接收方不论收到什么数据，都要发送确认包，确认包只确认连续的数据包的最后一项</li><li>发送方遇到连续三次相同的确认，但是没有出现确认超时的情况(收到了确认但是并非是正确的确认信息)，则认为在网络中出现了丢失数据包的情况，则立刻进行重传丢失的数据包</li></ul><h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><ul><li>在出现只丢失部分数据包的情况下，即出现快重传的情况时，不会将窗口设置为初始值，而是仅仅将窗口的大小减半，同时极大值设置为当前窗口的一半</li></ul><p><img src="/image/notebook/Computer-network/16.png" alt="TCP拥塞控制1"></p><p><img src="/image/notebook/Computer-network/17.png" alt="TCP拥塞控制2"></p><p><em>图中，0-1的过程为慢开始，1-2的过程即为拥塞避免，2-3的过程中出现了数据包确认超时，4-5的过程中发生了快重传和快恢复</em></p><h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><p>连接的三个阶段</p><ul><li>连接建立</li><li>数据传送</li><li>连接释放</li></ul><p>三个问题</p><ul><li>要使每一方能够确知对方的存在</li><li>要允许双方协商一些参数</li><li>能够对运输实体资源进行分配</li></ul><h3 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h3><p><img src="/image/notebook/Computer-network/18.png" alt="TCP三次握手"></p><ul><li>客户端(A) 和 服务器(B) 都处于 CLOSED(关闭) 状态</li><li>B 创建传输控制模块，进入 LISTEN(收听) 状态</li><li>A 创建传输控制模块，向 B 发送TCP连接请求，此报文中 SYN=1，且 seq=J，A 进入 SYN-SENT(同步已发送)</li><li>B 接收到请求，如果同意建立连接，则向 A 发送数据包，此报文中 SYN=1，ACK=1，且 ack=J+1，seq=K，进入 SYN-RCVD(同步收到)</li><li>A 收到 B 的确认后，再次给 B 发送确认数据包，此报文中 ACK=1，且ack=K+1，进入 ESTABLISHED(已建立连接)</li><li>B 收到 A 的确认后，也进入 ESTABLISHED(已建立连接)</li></ul><h3 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h3><p>略</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS-域名服务器"><a href="#DNS-域名服务器" class="headerlink" title="DNS(域名服务器)"></a>DNS(域名服务器)</h2><ul><li>功能：将域名转换为 IP 地址</li><li><p>域名结构：从域名的最后一个单词开始，通过 <code>.</code> 来分割，表示了“顶级域名”、“二级域名”、“三级域名”。例如对于域名：<code>mail.google.com</code>，顶级域名为：<code>com</code>，二级域名：<code>google</code>，三级域名：<code>mail</code>。无论域名内容是什么，一定是按照此逻辑进行分配。例如域名：<code>mail.zjgsu.edu.cn</code>的顶级域名为：<code>cn</code>，二级域名为：<code>edu</code>，三级域名为：<code>zjgsu</code>，四级域名：<code>mail</code></p><p>DNS 的<font color=red>递归</font>查询过程见<a href="https://hukeqing.github.io/2020/12/26/notebook/Computer-network-experiment/#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1-DNS">计算机网络实验复习</a></p></li></ul><p>递归是用户只向本地DNS服务器发出请求，然后等待肯定或否定答案。而迭代是本地服务器向根DNS服务器发出请求，而根DNS服务器只是给出下一级DNS服务器的地址，然后本地DNS服务器再向下一级DNS发送查询请求直至得到最终答案</p><h2 id="FTP-文件传送协议"><a href="#FTP-文件传送协议" class="headerlink" title="FTP(文件传送协议)"></a>FTP(文件传送协议)</h2><p>提供文件的交互式访问</p><ul><li>语序客户指明文件的类型与格式</li><li>允许文件具有存储权限</li><li>输入有效的口令</li><li>屏蔽了各计算机系统的细节</li></ul><h3 id="TFTP-简单文件传送协议"><a href="#TFTP-简单文件传送协议" class="headerlink" title="TFTP(简单文件传送协议)"></a>TFTP(简单文件传送协议)</h3><p>略</p><h2 id="TELNET-远程终端协议"><a href="#TELNET-远程终端协议" class="headerlink" title="TELNET(远程终端协议)"></a>TELNET(远程终端协议)</h2><p>明文的远程终端协议，<font color=red>目前通常使用 ssh(Secure Shell 加密的网络传输协议) 来代替 TELNET</font></p><h2 id="WWW-万维网"><a href="#WWW-万维网" class="headerlink" title="WWW(万维网)"></a>WWW(万维网)</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>明文传输的超文本传输协议，由于是明文传输，很容易受到中间人攻击，植入广告</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>加密传输的超文本传输协议，不会被中间人攻击</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="SMTP-简单邮件传送协议"><a href="#SMTP-简单邮件传送协议" class="headerlink" title="SMTP(简单邮件传送协议)"></a>SMTP(简单邮件传送协议)</h3><h3 id="IMAP和POP3-邮件接受协议"><a href="#IMAP和POP3-邮件接受协议" class="headerlink" title="IMAP和POP3(邮件接受协议)"></a>IMAP和POP3(邮件接受协议)</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作位置</th><th style="text-align:center">操作内容</th><th style="text-align:center">IMAP</th><th style="text-align:center">POP3</th></tr></thead><tbody><tr><td style="text-align:center">收件箱</td><td style="text-align:center">阅读、标记、移动、删除等操作</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">发件箱</td><td style="text-align:center">保存到已发送</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">创建文件夹</td><td style="text-align:center">新建自定义文件夹</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">草稿</td><td style="text-align:center">保存草稿</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">垃圾文件夹</td><td style="text-align:center">接受并移入垃圾文件夹的邮件</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">广告邮件</td><td style="text-align:center">接受并移入广告邮件夹的邮件</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr></tbody></table></div><h2 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP(动态主机配置协议)"></a>DHCP(动态主机配置协议)</h2><p>见<a href="https://hukeqing.github.io/2020/12/26/notebook/Computer-network-experiment/#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE-DHCP">计算机网络实验复习</a></p><h1 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h1><ul><li><a href="#IPv6">IPv6长度为128位</a></li><li><a href="#CSMA-CD-协议-Carrier-Sense-Multiple-Access-with-Collision-Detection-载波侦听多路访问-碰撞检测">CSMACD载波侦听多路访问/碰撞检测</a></li><li><a href="#TELNET-远程终端协议">比 TELNET 更好的远程终端协议——SSH</a></li><li><a href="#电子邮件">发送邮件的协议为SMTP，接受为IMAP和POP3</a></li><li><a href="#物理层下面的传输媒体">光纤分为单模光纤和多模光纤</a></li><li><a href="#截断二进制指数退避">最短帧长</a></li><li><a href="#DNS-域名服务器">给出域名问主机名</a></li><li><a href="#数据链路层协议">最大传输单元MTU=1500字节</a></li><li><a href="#通信系统中的术语">曼切斯特编码</a></li><li><a href="#截断二进制指数退避">截断二进制指数退避算法</a></li><li><a href="#ARP-地址解析协议">ARP</a></li><li><a href="#ICMP-网际控制报文协议-互联网控制消息协议">ICMP</a></li><li><a href="#点对点协议PPP">零比特填充</a></li><li><a href="#WWW-万维网">浏览器访问植入广告原理</a></li><li><a href="#DNS-域名服务器">DNS解析过程</a></li><li><a href="#互联网的路由选择协议">路由表的构建</a></li><li><a href="#ARP-地址解析协议">为什么不使用mac地址作为通信地址</a></li><li><a href="#子网的划分方法">网络划分子网</a></li><li><a href="#IP-数据报的格式">IP数据报结构</a></li><li><a href="#可靠传输的工作原理">TCP可靠的实现</a></li><li><a href="#TCP-的连接建立">TCP三次握手</a></li><li>安全的 web 协议——HTTPS</li><li>不同 vlan 之间通讯需要第三层交换机</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>课程</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次 Navicat 连接 MySQL 一直报认证错误(Access denied)</title>
    <link href="/2021/01/02/develop-note/mysql-reset/"/>
    <url>/2021/01/02/develop-note/mysql-reset/</url>
    
    <content type="html"><![CDATA[<p><em>今天一时兴起，想在 WSL2 里下个 MySQL。方法也很简单，直接 <code>sudo apt install mysql-server</code></em><br><em>本来以为顺风顺水，结果却在 Navicat 连接 MySQL 的操作上出事了</em></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Navicat 无法连接上 MySQL</p><h3 id="配置情况"><a href="#配置情况" class="headerlink" title="配置情况"></a>配置情况</h3><p>Navicat Premium 15.0.19<br>MySQL 8.0.22<br>WSL2(Ubuntu 20)</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>终端可以通过<code>sudo mysql</code>连上 MySQL<br>终端不可以通过<code>mysql -u root -p</code>的方式连接，显示密码错误(<code>Access denied for user &#39;root&#39;@&#39;localhost&#39;</code>)<br>终端可以通过默认用户连接(默认用户为 <code>/etc/mysql/debian.cnf</code> 文件中的 <code>debian-sys-maint</code>，密码为安装MySQL时随机生成得到的)<br>Navicat不可以通过直接连接或者通过 ssh 的方式连接，显示密码错误(<code>Access denied for user &#39;root&#39;@&#39;localhost&#39;</code>)<br>Navicat可以通过默认用户连接</p><h3 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h3><h4 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h4><p>首先是尝试了百度的结果，重置 MySQL 的 root 账户的密码<br>因为可以通过<code>sudo mysql</code>直接进入数据库，也就不需要那么多百度出来的奇奇怪怪的操作了<br>直接进入数据库，然后尝试了下面几行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;newPassword&#39;;<br>exit<br></code></pre></td></tr></table></figure><br>然后，测试<code>mysql -u root -p</code>连接——<strong>失败</strong></p><h4 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h4><p>后来在MySQL官网找到了重置root密码的方法，然后赶紧拿来测试<br><a href="https://dev.mysql.com/doc/refman/8.0/en/resetting-permissions.html">官网链接</a><br>其中的一点提到</p><blockquote><p>B.3.3.2.2 Resetting the Root Password: Unix and Unix-Like Systems</p></blockquote><p>大致操作就是先终止 MySQL，然后使用 MySQL 的附加参数来设置一个初始化文件，然后使得 MySQL 去运行此文件。</p><p>然后，测试<code>mysql -u root -p</code>连接——<strong>失败</strong></p><p>其实觉得挺奇怪的，既然都能重启 MySQL 了，说明你已经拿到这个设备的 root 权限了，为什么不直接用 <code>sudo mysql</code> 进入直接run这条命令呢？</p><h4 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h4><p>最终我在一份不起眼的博客上找到了解决方案<br><a href="https://phoenixnap.com/kb/access-denied-for-user-root-localhost">博客连接</a><br>其中提到了一个很重要的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;insert_password&#39;;<br></code></pre></td></tr></table></figure></p><blockquote><p>This command changes the password for the user root and sets the authentication method to mysql_native_password. This is a traditional method for authentication, and it is not as secure as auth_plugin.</p></blockquote><p>其中的<code>mysql_native_password</code>是所谓的传统验证方案，也就是 Navicat 连接 MySQL 的解决方案</p><p>然后将方案1的命令稍作改正得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br>alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;newPassword&#39;;<br>exit<br></code></pre></td></tr></table></figure><br>然后，测试<code>mysql -u root -p</code>连接——<strong>成功！</strong></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>mysql5.8开始将caching_sha2_password作为默认的身份验证插件，该caching_sha2_password和 sha256_password认证插件提供比mysql_native_password插件更安全的密码加密 ，并 caching_sha2_password提供了比更好的性能sha256_password。由于这些优越的安全性和性能特性 caching_sha2_password它是MySQL 8.0首选的身份验证插件，而且也是默认的身份验证插件而不是 mysql_native_password。此更改会影响服务器和libmysqlclient 客户端库；<font color=red>目前来说和经常使用的客户端软件兼容性不好</font>。</p><p>这也是导致目前 Navicat 无法连接到 MySQL 5.8及以后版本的原因。当然如此操作后的影响便是无法直接使用<code>sudo mysql</code>的方式连接到数据库，只能通过 <code>mysql -u root -p</code>的传统密码验证的方式来登陆</p>]]></content>
    
    
    
    <tags>
      
      <tag>短笔记</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验复习</title>
    <link href="/2020/12/26/notebook/Computer-network-experiment/"/>
    <url>/2020/12/26/notebook/Computer-network-experiment/</url>
    
    <content type="html"><![CDATA[<h1 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h1><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>A类线(T568A)颜色：白绿/绿/白橙/蓝/白蓝/橙/白棕/棕<br>B类线(T568B)颜色：白橙/橙/白绿/蓝/白蓝/绿/白棕/棕</p><h2 id="线"><a href="#线" class="headerlink" title="线"></a>线</h2><p>分为两种线：直连线和交叉线</p><p>直连线：线的两端使用的是相同类的线，即同时使用A类或者B类<br>交叉线：线的两端使用的是不同的线，一段为A类，一段为B类</p><h3 id="为什么有两种不同的线"><a href="#为什么有两种不同的线" class="headerlink" title="为什么有两种不同的线"></a>为什么有两种不同的线</h3><p>输入口和输出口的区别</p><p>如果使用的是直连线，则一段的输入端和另一端输入端的位置相同<br>而使用的是交叉线，则一段的输入端和另一端输入端的位置不同</p><h3 id="使用时间"><a href="#使用时间" class="headerlink" title="使用时间"></a>使用时间</h3><p>当一段为交换机，另一端不为交换机时，使用直连线<br>其他情况均使用交叉线</p><h1 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议(DHCP)"></a>动态主机配置协议(DHCP)</h1><p>用户利用有线或无线方式随机接入局域网，获得由DHCP服务器分配的临时IP地址</p><h2 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h2><ul><li>借助UDP协议、广播方式向局域网中所有DHCP服务器67端口发送DHCP搜索信息(DHCPDISCOVER)</li><li>每个DHCP服务器收到广播请求后回应一个有效IP地址，并对该IP地址进行锁定(DHCPOFFER)</li><li>客户机接受第一个回应的IP地址，并广播通知所有DHCP服务器确认接受。除分配该IP地址的服务器外，其他服务器解除对准备分配的IP地址的锁定，放回地址池(DHCPREQUEST)</li><li>被选中的DHCP服务器收到确认信息后，以广播方式答复确认信息(DHCPACK)</li></ul><h2 id="终止DHCP租借"><a href="#终止DHCP租借" class="headerlink" title="终止DHCP租借"></a>终止DHCP租借</h2><ul><li>超过服务器配置中所设置的时间，DHCP租借自动过期</li><li>未超过服务器配置中所设置的时间，客户机的TCP/IP配置中可进行手动终止。</li></ul><h1 id="域名解析服务-DNS"><a href="#域名解析服务-DNS" class="headerlink" title="域名解析服务(DNS)"></a>域名解析服务(DNS)</h1><p>域名解析系统，以符号名字代替纯数字（IP地址）对计算机进行标识。例如，将www.baidu.com解析为36.152.44.95</p><h2 id="域名分级"><a href="#域名分级" class="headerlink" title="域名分级"></a>域名分级</h2><p>例如：www.baidu.com<br>一级域名为：com<br>二级域名为：baidu<br>三级域名为：www</p><p>每一级域名的解析服务器(DNS)都知道其下一级域名的服务器的IP，同时也知道根服务器的IP</p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><ul><li>客户机（PC）向首选DNS服务器发起请求：“你知道www.baidu.com的IP吗？”如果首选DNS服务器知道（一般如果首选DNS服务器曾经解析过，那么会进行一段时间内的缓存，默认三天，如果正好在缓存时间内，那么首选服务器就会知道这个域名的IP）那么首选DNS 服务器就会直接给客户机返回域名的IP 地址</li><li>若首选DNS 服务器上没有相关信息，就不能直接返回域名的IP 地址，这时候，首选DNS 服务器就会去询问根DNS服务器（所有的 DNS 服务器都知道全球的 13 台DNS根服务器在哪里），根服务器可能不知道这个具体的 www.baidu.com 的IP地址，但是它知道一级域 com 的DNS服务器的IP（也就是说根服务器只负责维护所有的一级域，所以也就几百条数据在这里，虽然数据量少，但是它接受来自全球的请求，所以负载也很大）</li><li>根服务器将 com 的DNS服务器的IP地址返回给首选 DNS 服务器</li><li>首选DNS服务器再去请求 “com” DNS服务器：“你知道 www.baidu.com 的IP吗”，但是com DNS服务器也不知道 www.baidu.com 的IP，但是com 的DNS服务器知道 baidu.com 的IP</li><li>“com” 的DNS服务器将这个信息返回给首选 DNS 服务器</li><li>首选DNS服务器再去请求 “baidu.com” DNS服务器，这时候 baidu.com 服务器当然就会知道 www.baidu.com的IP地址</li><li>“baidu.com”DNS服务器将这个信息返回给首选DNS 服务器</li><li>首选DNS服务器将获取到的 www.baidu.com 的IP返回给客户机</li><li>客户机根据获取到的 www.baidu.com 的IP地址来访问WEB服务器</li><li>WEB服务器返回相关的数据</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">请求发起者</th><th style="text-align:center">请求接受者</th><th style="text-align:center">询问内容</th><th style="text-align:center">询问结果</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">PC</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">www.baidu.com</td><td style="text-align:center">暂时不回答</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">根服务器</td><td style="text-align:center">www.baidu.com</td><td style="text-align:center">com的DNS服务器的IP</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">com 的DNS服务器</td><td style="text-align:center">www.baidu.com</td><td style="text-align:center">baidu.com 的DNS服务器的IP</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">baidu.com 的DNS服务器</td><td style="text-align:center">www.baidu.com</td><td style="text-align:center">www.baidu.com的IP</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">PC</td><td style="text-align:center"></td><td style="text-align:center">回答序号1的询问，即返回www.baidu.com的IP</td></tr></tbody></table></div><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>缓存：将查找到的新域名解析结果置于本地缓存，以提高域名解析响应速度</li><li>复制：根服务器存在多个副本，为客户机请求提供最快速的响应</li></ul><h1 id="Internet服务管理器-IIS"><a href="#Internet服务管理器-IIS" class="headerlink" title="Internet服务管理器(IIS)"></a>Internet服务管理器(IIS)</h1><h2 id="Web访问过程"><a href="#Web访问过程" class="headerlink" title="Web访问过程"></a>Web访问过程</h2><ul><li>输入想要访问的网站的域名或者IP</li><li>DNS 解析网站的域名得到 IP</li><li>访问对方的 IP 的80端口找到对方的 web 服务器上的对应的网页</li><li>将网页下载到本地</li><li>浏览器渲染页面并显示出来</li></ul><h2 id="FTP访问过程"><a href="#FTP访问过程" class="headerlink" title="FTP访问过程"></a>FTP访问过程</h2><ul><li>输入想要访问的FTP的域名或者IP</li><li>DNS 解析网站的域名得到 IP</li><li>访问对方的 IP 的21端口找到对方的 FTP 服务器上的对应的文件夹</li><li>打开FTP站点目录</li></ul><h1 id="交换机-Switch"><a href="#交换机-Switch" class="headerlink" title="交换机(Switch)"></a>交换机(Switch)</h1><p>工作在OSI参考模型的第二层，即数据链路层</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">名称</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">应用层</td><td style="text-align:center">HTTP</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">表示层</td><td style="text-align:center">JPEG</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">会话层</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">传输层</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">网络层</td><td style="text-align:center">IP</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">数据链路层</td><td style="text-align:center">mac</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">物理层</td></tr></tbody></table></div><p>通常交换机只能看到数据包的mac地址，并不知道数据包所要发往的IP地址</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><ul><li>mac 地址与电脑硬件(网卡)有关</li><li>是网卡的硬件地址，全球唯一</li></ul><h3 id="mac地址表"><a href="#mac地址表" class="headerlink" title="mac地址表"></a>mac地址表</h3><p>存放物理地址与交换机端口映射关系的数据库</p><h2 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h2><h3 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h3><ul><li>数据包信息到达交换机</li><li>交换机根据数据包中封装的目的主机的MAC地址信息查找MAC地址表，同时根据源主机MAC地址信息更新自己的MAC地址表<ul><li>如果表中存在该目的主机的MAC地址，则从其对应的端口将数据包发送出去</li><li>如果表中不存在该目的主机的MAC地址，则将该数据包被<font color=red>泛洪</font>到所有端口</li></ul></li><li>目的主机PC2接收到数据包后，回复响应数据包给PC1，该过程与PC1发送数据包给PC2类似，但此时，PC2是源主机，PC1是目的主机</li><li>当PC2发送的响应数据包到达交换机时，交换机在转发数据包的同时，根据源主机MAC地址更新MAC地址表（在2.2的情况下，即在MAC地址表中添加一条PC2的MAC地址信息——MAC地址自动<font color=red>学习</font>）<h3 id="自动老化功能"><a href="#自动老化功能" class="headerlink" title="自动老化功能"></a>自动老化功能</h3></li><li>存在于MAC地址表中的MAC地址，如果长时间没有从该MAC地址收到包，则该MAC地址将被删除</li><li>当再次收到该MAC地址发送的包时，把该包作为广播包处理，重新学习</li></ul><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>交换机向MAC地址X转发数据包</p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一网段。交换机将不处理该数据包</p><p>如果交换机的每个端口都只连接一台 PC，那么交换机会正常进行转发而不会进行过滤</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="note note-warning">            <p>所有<font color=green>绿色</font>内容都为需要根据实际情况填写</p>          </div><div class="table-container"><table><thead><tr><th style="text-align:center">原状态</th><th style="text-align:center">新状态</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">用户模式</td><td style="text-align:center">特权模式</td><td style="text-align:center">enable</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">configure terminal</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">接口配置模式</td><td style="text-align:center">interface fa0/<font color=green>1</font></td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">多个接口配置模式</td><td style="text-align:center">interface range fa0/<font color=green>1</font> - <font color=green>10</font></td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">Vlan配置模式</td><td style="text-align:center">interface vlan <font color=green>1</font></td></tr><tr><td style="text-align:center">(多个)接口配置模式/Vlan配置模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">特权模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center">用户模式</td><td style="text-align:center">exit</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">用途</th><th style="text-align:center">命令行开头最后显示标志</th></tr></thead><tbody><tr><td style="text-align:center">用户模式</td><td style="text-align:center">实验课上无用</td><td style="text-align:center">&gt;</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center"><font color=red>查看</font>设备信息时使用</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center"><font color=red>设置</font>设备信息时使用</td><td style="text-align:center">(config)#</td></tr></tbody></table></div><h2 id="交换机的命令列表"><a href="#交换机的命令列表" class="headerlink" title="交换机的命令列表"></a>交换机的命令列表</h2><h3 id="特权模式下"><a href="#特权模式下" class="headerlink" title="特权模式下"></a>特权模式下</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">show mac-address-table</td><td style="text-align:center">查看mac地址表</td></tr><tr><td style="text-align:center">show aging-time</td><td style="text-align:center">查看自动老化时间</td></tr><tr><td style="text-align:center">show vlan brief</td><td style="text-align:center">查看 vlan 列表</td></tr></tbody></table></div><h3 id="全局配置模式"><a href="#全局配置模式" class="headerlink" title="全局配置模式"></a>全局配置模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">hostname <font color=green>新的名字</font></td><td style="text-align:center">修改交换机名称</td></tr><tr><td style="text-align:center">mac-address-table static <font color=green>mac</font> vlan <font color=green>1</font> interface fa0/<font color=green>1</font></td><td style="text-align:center">新增一条静态路由绑定</td></tr><tr><td style="text-align:center">no mac-address-table static <font color=green>mac</font> vlan <font color=green>1</font> interface fa0/<font color=green>1</font></td><td style="text-align:center">删除一条静态路由绑定</td></tr><tr><td style="text-align:center">vlan <font color=green>1</font></td><td style="text-align:center">新建/配置一个Vlan</td></tr><tr><td style="text-align:center">no vlan <font color=green>1</font></td><td style="text-align:center">删除一个Vlan</td></tr><tr><td style="text-align:center">ip routing</td><td style="text-align:center">启用路由功能(仅三层交换机)</td></tr></tbody></table></div><h3 id="配置模式"><a href="#配置模式" class="headerlink" title="配置模式"></a>配置模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">switchport mode access</td><td style="text-align:center">设置端口为普通端口</td></tr><tr><td style="text-align:center">switchport mode trunk</td><td style="text-align:center">设置端口为 trunk 口</td></tr><tr><td style="text-align:center">switchport access vlan <font color=green>1</font></td><td style="text-align:center">将端口设定为 vlan 1</td></tr><tr><td style="text-align:center">ip address <font color=green>IP</font> <font color=green>掩码</font></td><td style="text-align:center">设置当前Vlan的IP(仅在Vlan配置模式下使用，仅三层交换机可用)</td></tr></tbody></table></div><h1 id="路由器-Router"><a href="#路由器-Router" class="headerlink" title="路由器(Router)"></a>路由器(Router)</h1><h2 id="网络段计算公式"><a href="#网络段计算公式" class="headerlink" title="网络段计算公式"></a>网络段计算公式</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">IP <span class="hljs-meta">&amp; 掩码</span><br></code></pre></td></tr></table></figure><blockquote><p>例如，IP为192.168.1.1，掩码为255.255.255.0<br>则其网络段为<br><code>11000000.10101000.00000001.00000001 &amp;</code><br><code>11111111.11111111.11111111.00000000 =</code><br><code>11000000.10101000.00000001.00000000</code><br>即，网络段为：192.168.1.0</p></blockquote><p>交换机只能交换同一个网络段的数据包，不能交换不同网络段的数据包</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><div class="table-container"><table><thead><tr><th style="text-align:center">原状态</th><th style="text-align:center">新状态</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">用户模式</td><td style="text-align:center">特权模式</td><td style="text-align:center">enable</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">configure terminal</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">接口配置模式</td><td style="text-align:center">interface fa0/<font color=green>0</font></td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">子接口配置模式</td><td style="text-align:center">interface fa0/<font color=green>0</font>.<font color=green>1</font></td></tr><tr><td style="text-align:center">子接口配置模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">接口配置模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">特权模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center">用户模式</td><td style="text-align:center">exit</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">用途</th><th style="text-align:center">命令行开头最后显示标志</th></tr></thead><tbody><tr><td style="text-align:center">用户模式</td><td style="text-align:center">实验课上无用</td><td style="text-align:center">&gt;</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center"><font color=red>查看</font>设备信息时使用</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center"><font color=red>设置</font>设备信息时使用</td><td style="text-align:center">(config)#</td></tr><tr><td style="text-align:center">接口配置模式</td><td style="text-align:center"><font color=red>设置</font>单个具体的端口使用</td><td style="text-align:center">(config-if)#</td></tr></tbody></table></div><h2 id="路由器命令列表"><a href="#路由器命令列表" class="headerlink" title="路由器命令列表"></a>路由器命令列表</h2><h3 id="特权模式下-1"><a href="#特权模式下-1" class="headerlink" title="特权模式下"></a>特权模式下</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">show interface</td><td style="text-align:center">查看路由器端口信息</td></tr><tr><td style="text-align:center">show ip route</td><td style="text-align:center">查看路由信息</td></tr></tbody></table></div><h3 id="全局配置模式-1"><a href="#全局配置模式-1" class="headerlink" title="全局配置模式"></a>全局配置模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">hostname <font color=green>新的名字</font></td><td style="text-align:center">修改路由器名称</td></tr><tr><td style="text-align:center">ip route <font color=green>目标网段</font> <font color=green>掩码</font> <font color=green>下一个跳转的IP地址</font></td><td style="text-align:center">设置静态路由转发</td></tr></tbody></table></div><h3 id="配置模式-1"><a href="#配置模式-1" class="headerlink" title="配置模式"></a>配置模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">ip address <font color=green>IP</font> <font color=green>掩码</font></td><td style="text-align:center">设置路由器的此端口的IP和掩码</td></tr><tr><td style="text-align:center">no shutdown</td><td style="text-align:center">启用此端口</td></tr><tr><td style="text-align:center">encapsulation dot1Q <font color=green>Vlan号</font></td><td style="text-align:center">封装802.1Q(进入子端口的时候，封装此协议可以为此子端口设置IP)</td></tr></tbody></table></div><div class="note note-success">            <p>注意，别忘记给PC设置网关</p>          </div><h1 id="Ping-的返回结果含义"><a href="#Ping-的返回结果含义" class="headerlink" title="Ping 的返回结果含义"></a>Ping 的返回结果含义</h1><h2 id="Requesttimed-out-超时"><a href="#Requesttimed-out-超时" class="headerlink" title="Requesttimed out 超时"></a>Requesttimed out 超时</h2><ul><li>对方已关机</li><li>对方和我不在同一个网段</li><li>对方防火墙设置了ICMP数据包过滤</li><li>错误设置IP地址</li></ul><h2 id="Destinationhost-Unreachable-无法到达"><a href="#Destinationhost-Unreachable-无法到达" class="headerlink" title="Destinationhost Unreachable(无法到达)"></a>Destinationhost Unreachable(无法到达)</h2><ul><li>对方与自己不在同一网段内，而自己又未设置默认的路由(网关)</li><li>网线出了故障</li></ul><h2 id="BadIP-address-错误的IP"><a href="#BadIP-address-错误的IP" class="headerlink" title="BadIP address(错误的IP)"></a>BadIP address(错误的IP)</h2><ul><li>DNS服务器未设置</li><li>IP地址不存在</li></ul><h2 id="Sourcequench-received"><a href="#Sourcequench-received" class="headerlink" title="Sourcequench received"></a>Sourcequench received</h2><ul><li>对方或中途的服务器繁忙无法回应</li></ul><h2 id="Unknownhost-不知名主机"><a href="#Unknownhost-不知名主机" class="headerlink" title="Unknownhost(不知名主机)"></a>Unknownhost(不知名主机)</h2><p>该远程主机的名字不能被域名服务器（DNS）转换成IP地址</p><ul><li>域名服务器有故障</li><li>名字不正确</li><li>网络管理员的系统与远程主机之间的通信线路有故障</li></ul><h2 id="Noanswer"><a href="#Noanswer" class="headerlink" title="Noanswer"></a>Noanswer</h2><ul><li>中心主机没有工作</li><li>本地或中心主机网络配置不正确</li><li>本地或中心的路由器没有工作</li><li>通信线路有故障</li></ul><h1 id="网络协议分析"><a href="#网络协议分析" class="headerlink" title="网络协议分析"></a>网络协议分析</h1><h2 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP(地址解析协议)"></a>ARP(地址解析协议)</h2><ul><li>工作在数据链路层</li><li>将IP地址转化成物理地址(mac)</li></ul><blockquote><p>在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p><p>另外，当发送主机和目的主机不在同一个局域网中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或ARP代理（ARP Proxy）。</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>有目的主机IP地址对应的MAC地址，直接转发</li><li>没有目的主机IP地址对应的MAC地址，在本网段发起ARP请求广播包进行查询</li><li>根据源主机的MAC地址信息，更新ARP列表</li></ul><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><div class="table-container"><table><thead><tr><th style="text-align:center">长度(位)</th><th style="text-align:center">48</th><th style="text-align:center">48</th><th style="text-align:center">16</th><th style="text-align:center">16</th><th style="text-align:center">16</th><th style="text-align:center">8</th><th style="text-align:center">8</th><th style="text-align:center">16</th><th style="text-align:center">48</th><th style="text-align:center">32</th><th style="text-align:center">48</th><th style="text-align:center">32</th></tr></thead><tbody><tr><td style="text-align:center">数据类型</td><td style="text-align:center">目标以太网地址</td><td style="text-align:center">源以太网地址</td><td style="text-align:center">帧类型</td><td style="text-align:center">硬件类型</td><td style="text-align:center">协议类型</td><td style="text-align:center">硬件地址长度</td><td style="text-align:center">协议地址长度</td><td style="text-align:center">操作码</td><td style="text-align:center">源硬件地址</td><td style="text-align:center">源协议地址</td><td style="text-align:center">目标硬件地址</td><td style="text-align:center">目标协议地址</td></tr><tr><td style="text-align:center">英文名</td><td style="text-align:center">DEST ADDR</td><td style="text-align:center">SRC ADDR</td><td style="text-align:center">TYPE</td><td style="text-align:center">HARDWARE TYPE</td><td style="text-align:center">PROTOCOL TYPE</td><td style="text-align:center">HLEN</td><td style="text-align:center">PLEN</td><td style="text-align:center">OPCODE</td><td style="text-align:center">SOURCE MAC</td><td style="text-align:center">SOURCE IP</td><td style="text-align:center">TARGET MAC</td><td style="text-align:center">TARGET IP</td></tr><tr><td style="text-align:center">ARP(请求)</td><td style="text-align:center">FF:FF:FF:FF:FF:FF</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0x0001</td><td style="text-align:center">0x0800</td><td style="text-align:center">0x06</td><td style="text-align:center">0x04</td><td style="text-align:center">0x0001</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0000.0000.0000</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ARP(回复)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0x0001</td><td style="text-align:center">0x0800</td><td style="text-align:center">0x06</td><td style="text-align:center">0x04</td><td style="text-align:center">0x0002</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><ul><li>硬件类型：如以太网（0x0001）、分组无线网</li><li>协议类型：如网际协议(IP)（0x0800）、IPv6（0x86DD）</li><li>硬件地址长度：每种硬件地址的字节长度，一般为6（以太网）</li><li>协议地址长度：每种协议地址的字节长度，一般为4（IPv4）</li><li>操作码：1为ARP请求，2为ARP应答，3为RARP请求，4为RARP应答</li><li>源硬件地址：n个字节，n由硬件地址长度得到，一般为发送方MAC地址</li><li>源协议地址：m个字节，m由协议地址长度得到，一般为发送方IP地址</li><li>目标硬件地址：n个字节，n由硬件地址长度得到，一般为目标MAC地址</li><li>目标协议地址：m个字节，m由协议地址长度得到，一般为目标IP地址</li></ul><p>前14字节为以太网首部，后28字节为ARP请求/应答</p><h2 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP(传输控制协议)"></a>TCP(传输控制协议)</h2><ul><li>工作在传输层</li><li>实现进程到进程的可靠的数据流传送服务</li><li>标识主机位置：地址(IP)</li><li>标识进程：端口</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>客户端（通过执行connect函数）向服务器端发送一个SYN包，请求一个主动打开。该包携带客户端为这个连接请求而设定的随机数X作为消息序列号(seq=X)</li><li>服务器端收到一个合法的SYN包后，把该包放入SYN队列中；回送一个SYN/ACK。ACK的确认码应为X+1，SYN/ACK包本身携带一个随机产生的序号Y(seq=Y,ack=X+1)</li><li>客户端收到SYN/ACK包后，发送一个ACK包，该包的序号被设定为X+1，而ACK的确认码则为Y+1。然后客户端的connect函数成功返回(seq=X+1 ack=Y+1)</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><em>貌似不考</em></p><h3 id="数据包-1"><a href="#数据包-1" class="headerlink" title="数据包"></a>数据包</h3><div class="table-container"><table><thead><tr><th style="text-align:center">长度(位)</th><th style="text-align:center">16</th><th style="text-align:center">16</th><th style="text-align:center">32</th><th style="text-align:center">32</th><th style="text-align:center">4</th><th style="text-align:center">6</th><th style="text-align:center">6</th><th style="text-align:center">16</th><th style="text-align:center">16</th><th style="text-align:center">16</th></tr></thead><tbody><tr><td style="text-align:center">数据类型</td><td style="text-align:center">来源连接端口</td><td style="text-align:center">目的连接端口</td><td style="text-align:center">序列号码</td><td style="text-align:center">确认号码</td><td style="text-align:center">资料偏移</td><td style="text-align:center">保留</td><td style="text-align:center">标志位</td><td style="text-align:center">窗口大小</td><td style="text-align:center">校验和</td><td style="text-align:center">紧急指针</td></tr><tr><td style="text-align:center">英文名</td><td style="text-align:center">SOURCE PORT</td><td style="text-align:center">DESTINATION PORT</td><td style="text-align:center"><font color=red>SEQ</font>UENCE NUMBER</td><td style="text-align:center"><font color=red>ACK</font>NOWLEDGEMENT NUMBER</td><td style="text-align:center">OFFSET</td><td style="text-align:center">RESERVED</td><td style="text-align:center">FLAGS</td><td style="text-align:center">WINDOW</td><td style="text-align:center">CHECKSUM</td><td style="text-align:center">URGENT POINTER</td></tr><tr><td style="text-align:center">TCP第一次握手</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">X</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0b000010</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TCP第二次握手</td><td style="text-align:center">B</td><td style="text-align:center">A</td><td style="text-align:center">Y</td><td style="text-align:center">X+1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0b010010</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TCP第三次握手</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">X+1</td><td style="text-align:center">Y+1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0b010000</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h1 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h1><h2 id="交换机配置静态路由"><a href="#交换机配置静态路由" class="headerlink" title="交换机配置静态路由"></a>交换机配置静态路由</h2><p>PC<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">C:\&gt;ipconfig /<span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><br>获取FastEthernet0的物理地址(Physical Address)为<code>00E0.A3BA.8021</code></p><p>交换机<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Switch</span>(config)# mac-address-table static <span class="hljs-number">00</span>E<span class="hljs-number">0</span>.A<span class="hljs-number">3</span>BA.<span class="hljs-number">8021</span> vlan <span class="hljs-number">1</span> interface fa<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br>即完成了将mac地址为<code>00E0.A3BA.8021</code>的PC与<code>fa0/1</code>端口绑定</p><h2 id="路由器设置端口"><a href="#路由器设置端口" class="headerlink" title="路由器设置端口"></a>路由器设置端口</h2><p>路由器<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Router(<span class="hljs-params">config</span>)</span># interface fa0/<span class="hljs-number">0</span><br><span class="hljs-constructor">Router(<span class="hljs-params">config</span>-<span class="hljs-params">if</span>)</span># ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br></code></pre></td></tr></table></figure><br>完成将<code>fa0/0</code>端口的IP设置为<code>192.168.1.1</code>，掩码为<code>255.255.255.0</code></p><h2 id="三层交换机实现Vlan间通讯"><a href="#三层交换机实现Vlan间通讯" class="headerlink" title="三层交换机实现Vlan间通讯"></a>三层交换机实现Vlan间通讯</h2><div class="table-container"><table><thead><tr><th style="text-align:center">设备</th><th style="text-align:center">属性</th></tr></thead><tbody><tr><td style="text-align:center">PC1</td><td style="text-align:center">IP：192.168.10.10，掩码：255.255.255.0，网关：192.168.10.1</td></tr><tr><td style="text-align:center">PC2</td><td style="text-align:center">IP：192.168.20.10，掩码：255.255.255.0，网关：192.168.20.1</td></tr><tr><td style="text-align:center">PC3</td><td style="text-align:center">IP：192.168.10.20，掩码：255.255.255.0，网关：192.168.10.1</td></tr><tr><td style="text-align:center">PC4</td><td style="text-align:center">IP：192.168.20.20，掩码：255.255.255.0，网关：192.168.20.1</td></tr><tr><td style="text-align:center">交换机1</td><td style="text-align:center">与PC1和PC2连接，分别连在fa0/1 fa0/2口，fa0/3与三层交换机连接</td></tr><tr><td style="text-align:center">交换机2</td><td style="text-align:center">与PC3和PC4连接，分别连在fa0/1 fa0/2口，fa0/3与三层交换机连接</td></tr><tr><td style="text-align:center">三层交换机</td><td style="text-align:center">与交换机1和交换机2连接，分别连在fa0/1 fa0/2口</td></tr></tbody></table></div><p>交换机1<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">1</span><br>switchport access vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">2</span><br>switchport access vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">3</span><br>switchport mode trunk<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><br>交换机2<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">1</span><br>switchport access vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">2</span><br>switchport access vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">3</span><br>switchport mode trunk<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><br>交换机3<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface vlan <span class="hljs-number">10</span><br>ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">10.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br><span class="hljs-keyword">exit</span><br>interface vlan <span class="hljs-number">20</span><br>ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">20.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br><span class="hljs-keyword">exit</span><br>ip routing<br></code></pre></td></tr></table></figure></p><h2 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h2><div class="table-container"><table><thead><tr><th style="text-align:center">设备</th><th style="text-align:center">属性</th></tr></thead><tbody><tr><td style="text-align:center">PC1</td><td style="text-align:center">IP：192.168.10.10，掩码：255.255.255.0，网关：192.168.10.1</td></tr><tr><td style="text-align:center">PC2</td><td style="text-align:center">IP：192.168.20.10，掩码：255.255.255.0，网关：192.168.20.1</td></tr><tr><td style="text-align:center">交换机</td><td style="text-align:center">与PC1和PC2连接，分别连在fa0/1 fa0/2口，fa0/3与路由器连接</td></tr><tr><td style="text-align:center">路由器</td><td style="text-align:center">与交换机连接，连在fa0/0口</td></tr></tbody></table></div><p>交换机<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">1</span><br>switchport access vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">2</span><br>switchport access vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">3</span><br>switchport mode trunk<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><br>路由器<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>interface fa0/<span class="hljs-number">0</span><br>no shutdown<br>interface fa0/<span class="hljs-number">0.1</span><br>encapsulation dot1Q <span class="hljs-number">10</span><br>ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">10.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>no shutdown<br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">0.2</span><br>encapsulation dot1Q <span class="hljs-number">20</span><br>ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">20.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>no shutdown<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>课程</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL1 使用 Docker 一直无法启动</title>
    <link href="/2020/12/24/develop-note/wsl-docker/"/>
    <url>/2020/12/24/develop-note/wsl-docker/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>WSL1 无法正常启动 Dokcer，Dokcer一直处于 not running 状态</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>WSL1 是伪 Linux，实际上仍然是 Windows 底层，而 Docker 是基于系统底层实现的，这就导致了无法在 Windows(WSL1) 上运行 Linux 版本的 Dokcer<br>使用 WSL2 则可以正常使用 Docker，目前上述问题在不使用 WSL2 的情况下，暂时无法解决</p>]]></content>
    
    
    
    <tags>
      
      <tag>短笔记</tag>
      
      <tag>Dokcer</tag>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的ACM脚印</title>
    <link href="/2020/12/21/acm/myACM/"/>
    <url>/2020/12/21/acm/myACM/</url>
    
    <content type="html"><![CDATA[<p>2020年12月20日，南京区域赛结束，同时结束的，还有我的两年多的ACM生涯<br>接下来的寒假重心会向着找实习的方向努力，当然明年还有线下的区域赛、EC-finial以及明年的省赛等等，我都会去认真准备。</p><h1 id="这篇文章会写什么"><a href="#这篇文章会写什么" class="headerlink" title="这篇文章会写什么"></a>这篇文章会写什么</h1><ul><li>关于我<ul><li>我的ACM简单的回顾</li><li>我的ACM成绩</li></ul></li><li>写给新人<ul><li>ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别</li><li>ACM到底带给我什么了</li><li>为什么要打ACM</li><li>什么样的人适合去打ACM，什么样的人不适合去打ACM</li></ul></li><li>写给已经进入了ACM的人<ul><li>我在ACM的训练计划</li><li>除了ACM之外的计划</li></ul></li><li>关于ACM写题<ul><li>ACM算法的学习规划</li><li>我的一些经验之谈</li></ul></li></ul><p>这篇文章更多的是想来自我总结一下历史，如果与你的理解有出入也请见谅</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><h2 id="我的ACM简单的回顾"><a href="#我的ACM简单的回顾" class="headerlink" title="我的ACM简单的回顾"></a>我的ACM简单的回顾</h2><h3 id="进入大学之前"><a href="#进入大学之前" class="headerlink" title="进入大学之前"></a>进入大学之前</h3><p>我是2018年进入的大学，在这之前，我压根没有听说过ACM，也完全不知道这类竞赛，高中也是没有打过OI，也就是真正的纯粹的小白。当然，我的高中压根就不知道有什么叫OI的比赛，可能这就是所谓的省B类学校吧</p><p>但是我有优势，我从高一开始自学了程序，我当时想自己写游戏，然后学起来Unity了，也就顺便学了C#。至于优势，大概就是对程序有了自己的理解吧。如果让我对代码理解这个事情上进行一个分级的话，我会这样分：</p><ul><li>完全不会程序（基本上就是那些完全没有学过代码的人）</li><li>学会了顺序、选择、循环语句（一般是刚刚开始学程序的人，对程序是万能的这条表示怀疑的人）</li><li>能够灵活的运用上述三种语句（突然发现仅使用这三种语句居然可以实现一切逻辑，相信代码是万能的，只是需要写代码的。通常这类人同样相信代码是高效的，认为所有的事情基本上都可以在电脑上花费一小段的时间就能得出结果）</li><li>知道了代码是非常局限的，计算机能计算的速度是非常有限的，在解决一个问题前会思考这个问题的逻辑，对这个问题进行优化以适合计算机去运行，这类人也就是一个ACMer的入门点</li></ul><p>而那时候的我，大概就是第三类的人，比起同时期的同学，只能说我拥有着非常好的起点</p><p>但是，实际上，通过一个学期的学习，基本上所有的学生都能到达这个水平</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>大学的第一个学期，课程安排是学C语言，但是我其实并不需要，因为这些东西只需要我把我学C#的知识转成C就行了</p><p>而这个学期，校集训队也联系上了我，只不过因为我有提前的知识了，虽然我在那个时候还完全不知道对于代码还有第四层理解<br>当然，慢慢的我也接触到了很多算法，例如dfs、bfs之类的，只能说我在那个时候对ACM的理解还存在于ACM是提供更多的解决问题的办法而已<br>后来，学到了在ACM中最重要的东西：复杂度<br>也慢慢的开始学习到各种基础的算法：gcd、最短路、背包问题、KMP等等之类的</p><p>后来，我在大一快结束的时候，和另外两位大一参加了西安邀请赛，然后成功打铁……<br>紧接着是校赛，但是那次校赛的难度太高，导致全场只有20个人过题，我有幸过了两题。但是我和之前组队的两个大一的同学分开了队伍。<br>然后是浙江省省赛，和两个大二的人组队，然后继续打铁<br>再接下来是南昌邀请赛，我终于拿到了人生以来的第一个奖牌：铜</p><p>然后就是整整一个暑假的集训，杭电的多校、牛客的多校，题目的难度对于当时我而言，未免是过高了一些。那两个月，可谓是绝对的自闭</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>大二开始，大概是因为经历了暑假的自闭式训练，拿下了一个ICPC的区域赛银牌，虽然是银川偷鸡，但基本上是我一个人完成的比赛，而且其实本来很有希望冲击金牌</p><p>大二下半学期，因为疫情的原因，荒废了很久，没有出去打比赛，只能说是不断的学习吧。<br>也趁着疫情，顺便把CodeForces上把我的两个账号都刷到了紫名</p><p>当然，因为写的题多了，代码写的多了，感觉自己写题目的习惯开始发生了改变，特别是经常打CodeForces后，感觉自己对很多思维的理解在不断的加深。大一选择了图论方向，大二开始学数据结构，然后再学了字符串，稍微了解了dp，队内也把构造题的任务分配给了我</p><h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>这个学期难得有了好多场比赛，而我们原来参加了西安邀请赛的三个人，我们重新组成了完整的队伍，也夺下了省赛银牌、CCPC威海铜牌、ICPC南京银牌这样三个牌。</p><h2 id="我的ACM成绩"><a href="#我的ACM成绩" class="headerlink" title="我的ACM成绩"></a>我的ACM成绩</h2><p>到目前为止，总共拿下了两个ICPC区域赛银牌，一个CCPC的铜牌，一个浙江省省赛银牌，一个ICPC邀请赛铜牌，Codeforces两个账号都是紫名，准备寒假冲击橙名。接下来会参加一场线下的ICPC比赛以及EC-finial。未来可能在能够拿到offer的情况下，继续回来参加ACM竞赛</p><h1 id="写给新人"><a href="#写给新人" class="headerlink" title="写给新人"></a>写给新人</h1><h2 id="ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别"><a href="#ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别" class="headerlink" title="ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别"></a>ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别</h2><p>如果你是计算机学院的，那么你需要追求的、考虑的唯一的竞赛就是ACM</p><p>ACM是一个非常全面的竞赛，如果你说你只是喜欢数学，那么ACM比数学建模之类的数学竞赛更加具有挑战性，同样，难度更高。对的，在我的认知中，ACM对数学的要求甚至远远高于数学竞赛。因为ACM和其他比赛不一样的一点，便是ACM不设置任何的知识点上界，越新的知识点，越高级的知识点，ACM都可以考。甚至任何一道数学竞赛的题，如果你在ACM中见到，都是合情合理的。在打ACM的时候，这个知识点不会的情况是很正常的，是所有参加了ACM竞赛的人可以深切感受到的。而如果你只是去打数学之类的竞赛，如果你不能到达一个很高的层次，你可能很难体会到那种，自己完全不会，完全是毫无能力的那种绝望感。而在ACM，你可以在任何一场比赛中见到，甚至是随便在点开的一场比赛。</p><p>其次，ACM是一个非常公平、公正同时也是非常严格、残酷的比赛，甚至因为它的机制，你可以认为它是你整个大学生涯中见到过，最公平，也是唯一一个能够让参赛选手心服口服的比赛。因为ACM几乎不存在任何的主观因素，你只有准确完整的解决这个问题，你才能拿到那么一点成绩分。而且ACM系列竞赛结束，如果这场比赛有任何一道题有一些问题，通常出题人都会出面道歉。这也是我第一次知道，原来负责出题的人也是要道歉的。从那样的高考制度过来，我们甚至都不会去关心出题人是谁，即使他出了岔子，也会有专门的公关来解决。ACM却没有这些无聊的内容。</p><p>数学建模也好，挑战杯也罢，评委老师评分制意味着主观可以胜过客观，甚至，到最后可能变成了PPT大赛。如果说这类竞赛的好处，我觉得除了给你提高了拿到奖学金的可能性，对于自身能力的提升以及后续的工作而言甚至意义并不大。而奖学金，能比得上你找到一个好工作后在一个月内赚的钱多吗？你难道能一辈子拿奖学金过日子吗？当然这样的人是存在的，但是我相信大多数读者也和我一样，觉得这是一种奢望。</p><h2 id="ACM到底带给我什么了"><a href="#ACM到底带给我什么了" class="headerlink" title="ACM到底带给我什么了"></a>ACM到底带给我什么了</h2><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>我在ACM集训队的第一周，我所得到的知识，是我的室友们在大学四年内都可能会学不清楚、理不通的知识，而那些知识点，在我经历了两年多的ACM训练后觉得，这些只不过应该是理所当然会的、最基本的知识。这些知识点带给我的财富，是我在经历了四五个项目后，才意识到的我们与其他人的差距。ACM的知识点，只要你未来是做计算机行业的，那么它一定会在每一个角落里发挥着它的作用。</p><h3 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h3><p>ACM的题，对一个人的思维能力的提升有着非常恐怖的作用。特别是当你频繁的打Codeforces比赛时，你会深切的体会到自己的思维能力在以非常恐怖的速度进步。而与思维能力直接挂钩的，便是逻辑思路以及问题的敏感性。如果有人去看过杜老师的Codeforces录播视频，看过tourist的比赛视频，你会发现他们基本上并不会去论证一个方法的可行性，他们通常在读到这道题的时候，会反应过来这题“好像这样搞搞”、“在随便暴力一下”、“应该就对了”。这样的思路也正是我现在打Codeforces的一种感觉，当然我还不能到达杜老师这样对于这么难的题也可以如此轻松的想出解法，但是我仍然觉得我思考问题的思路和方向变得非常的开阔，而且思考问题的逻辑自然变得严谨合理。</p><h3 id="代码实现能力"><a href="#代码实现能力" class="headerlink" title="代码实现能力"></a>代码实现能力</h3><p>ACM的题，难度较高的题，有些需要各种数据结构的嵌套，需要各种开辟各种奇奇怪怪的数组。而你需要在短时间内完成代码的编写和调试，这无疑是对代码能力的直接挑战。例如Codeforces，5道题目只有两个小时，除掉读题（纯英文题面）和思考问题的时间，你又有多少时间可以来写代码调试代码呢？当室友还在为编译出错烦恼时，我们基本就不需要调试百行代码以下的程序，因为只需要简单的测试证明其确实没有错误即可。</p><h3 id="ACM朋友圈"><a href="#ACM朋友圈" class="headerlink" title="ACM朋友圈"></a>ACM朋友圈</h3><p>ACM届有一个最高级别的竞赛，被称为WF（world finial）——世界总决赛。这场比赛的含金量有多高？也许有人会说，最多也就是拿到金牌可以全球500强随意挑。但是，实际上只需要你碰到了这个比赛的边界，你只要有幸被邀请参加了这场比赛，不论你的名次，这个星球上的企业你已经可以随意选了，而且本科毕业就可以去工作的那种。而我们平时聊天水群，里面有的是因为ACM成绩优异而进入Google中国、微软亚洲研究院的人。而对于正常学业而言，各位也应该知道你需要读多少年的书才有胆量往这些企业中投递一份简历</p><h3 id="学长学姐"><a href="#学长学姐" class="headerlink" title="学长学姐"></a>学长学姐</h3><p>通常能坚持下来打ACM的都是能够在思维、能力、勤奋或者智商上略胜一筹的人，那么和这样的学长学姐在同一个实验室的屋檐下打比赛，你能得到的帮助和支持，远远超过参加社团带来的收益。</p><h3 id="直面清北复交"><a href="#直面清北复交" class="headerlink" title="直面清北复交"></a>直面清北复交</h3><p>ACM竞赛是所有队伍在相同地点使用相同设备在相同的时间内解决相同的题目。</p><p>而你的对手则是来自全国的大学，对，北大清华每年都会来，而且非常重视。</p><p>ACM从来就没有院赛、校赛、省赛等等一大堆乱七八糟的东西，虽然他们确实存在但是他们并不是被官方承认的。ACM只有区域赛，（比如Asia-East东亚地区），区域总决赛（比如EC-finial，东亚地区总决赛），和世界总决赛（WF）。无论在哪个比赛，你都可能会遇到任何一个学校的队伍。所以在这样的比赛中，你可以很清楚的知道自己的水平在全地区范围内的位置，对自己的能力有一个更好的评估，能够看到外面更加广阔的天空。而不是拘泥于那么小的一个地区，争夺那么毫无意义的第一名</p><h2 id="为什么要打ACM"><a href="#为什么要打ACM" class="headerlink" title="为什么要打ACM"></a>为什么要打ACM</h2><p>因为我要证明我自己</p><p>在ACM比赛中，你会真实的，亲身和北大清华等等高校在同一个体育馆里，使用相同的设备相同的时间来解决相同的问题。那么你为什么不去证明自己比他们强？我知道这通常不可能，因为他们也会派出他们最强的队伍来与你们竞技。但是我们需要的就是在这么多的强队中，证明我们自己的能力。在计算机领域内最有影响力的比赛中，证明自己而已</p><h2 id="什么样的人适合去打ACM，什么样的人不适合去打ACM"><a href="#什么样的人适合去打ACM，什么样的人不适合去打ACM" class="headerlink" title="什么样的人适合去打ACM，什么样的人不适合去打ACM"></a>什么样的人适合去打ACM，什么样的人不适合去打ACM</h2><p>ACM竞赛是一个需要大量的时间去投入，但是到很久之后才会有结果的产出。这和其他竞赛不同，数学建模通常你只需要很短的时间训练就能拿出成绩，而一个ACMer，在大三之前甚至可能都没有一点点成果。但是你在大一大二的投入终将会给你在大二下至大三上的时候带来丰富的回报。</p><p>这样的回报，需要愿意投资的人耐心投资才有可能赚得盆满钵满，一旦出现懈怠都有可能颗粒无收。<strong>耐心、专注、勤奋、自觉</strong>这些是一个ACMer必须要具备的因素。</p><h1 id="写给已经进入了ACM的人"><a href="#写给已经进入了ACM的人" class="headerlink" title="写给已经进入了ACM的人"></a>写给已经进入了ACM的人</h1><h2 id="我在ACM的训练计划"><a href="#我在ACM的训练计划" class="headerlink" title="我在ACM的训练计划"></a>我在ACM的训练计划</h2><ul><li>保持在Codeforces的个人刷题，最好是现场比赛，其次是复现比赛。Codeforces对训练一个人的思维能力有者极大的帮助作用，而且其出题非常的新颖，是我认为最适合ACMer进行个人训练的平台。Codeforces的思维题数量非常庞大，而且非常的有趣。正式的区域赛等比赛，通常思维题也会占据很大一部分比重。</li><li>队伍内保持至少一周一场往年比赛的复现赛，我们队在长达几个月的集训时间内保持了一周两场比赛且不耽误正常课程。</li><li>当你决定要写ACM题时，请不要断开，也尽可能避免使用碎片化的时间学习，这对学习的进度没有任何帮助，除非你只是突然需要回忆一个知识点。</li><li>在实验室内写题而不是在寝室或者图书馆或者其他任何地方写题。</li></ul><h2 id="除了ACM之外的计划"><a href="#除了ACM之外的计划" class="headerlink" title="除了ACM之外的计划"></a>除了ACM之外的计划</h2><p>ACM毕竟只是我们大学的一个工具，我们希望它能够服务于我们找工作、服务于我们在其他领域的发展。不可以把ACM当成是自己在大学里唯一执着的对象，甚至把它树立为人生目标，这不合实际也没有意义，反而会影响你的正常社交与生活，这不应该是一个人的目标。</p><h1 id="关于ACM写题"><a href="#关于ACM写题" class="headerlink" title="关于ACM写题"></a>关于ACM写题</h1><h2 id="ACM算法的学习规划"><a href="#ACM算法的学习规划" class="headerlink" title="ACM算法的学习规划"></a>ACM算法的学习规划</h2><p>在经历了两年多的学习之后我发现，其实很多的算法并没有太多的学习意义，或者说不必要为其投入过多的经历去学习。<br>我是负责队伍内的图论+字符串，以及构造题思维题，会数据结构，了解dp和树上问题。<br>另外一位队友负责计算几何和博弈论，以及数论，会dp，了解图论和树上问题<br>还有一位队友负责了数据结构和dp，以及树上问题，会数论，了解图论<br>基本上可以说是覆盖了所有的知识面，而且大部分知识面都是有多个人会。</p><p>我以我熟悉的图论为例，诸如“最大流”这些个算法，通常对于一个银牌队伍而言，其实学习的意义并不大。因为我至今未见到过最大流题的难度低于金牌题的（按照实际区域赛出题情况）相反，灵活的结合思维和拓扑排序，你会发现图论问题变得非常简单。很多区域赛的图论的铜牌题在你眼里变成了暴力傻逼题。这是对于一个图论选手在频繁使用图论相关的知识点的时候自然而然形成的。</p><p>我认为把学习那些过高的知识点重要性低于去熟练掌握最基本的算法的内容。</p><p>对于字符串也一样，上一次看到“回文树”是在复现赛上看到的，是一道金牌题，虽然对于会“回文树”的队伍而言相对简单很多，但是作为一道金牌题，很多时候在比赛现场可能根本没有时间去看这样一道题。</p><p>当然你的队伍是为了冲金牌的，这些知识点当然也应该成为你的必须知识点之一。</p><h2 id="我的一些经验之谈"><a href="#我的一些经验之谈" class="headerlink" title="我的一些经验之谈"></a>我的一些经验之谈</h2><ul><li>看题一定要看数据，通过数据大小猜测算法的复杂度，再去考虑可能的算法逻辑。通常为了卡掉错误的算法，正确算法的复杂度应该在$1e6-1e8$之间，前者考虑可能有很大的常数的复杂度，后者则是最差的不可能发生的情况下的复杂度。</li><li>队伍内除了在最后冲刺的时候，其他时间内务必保证多开，无论何时也不要三个人讨论同一个问题，即使你们现在被榜丢下了。甚至很多时候可以尝试三开</li><li>队伍中每个人都应该具备非常良好的代码能力，除非你们队伍中专门有数学专业的人帮忙</li></ul><p>Shiroha @2020.12.21凌晨1点30分</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
